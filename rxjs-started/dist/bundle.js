!function(n){var t={};function g(e){if(t[e])return t[e].exports;var I=t[e]={i:e,l:!1,exports:{}};return n[e].call(I.exports,I,I.exports,g),I.l=!0,I.exports}g.m=n,g.c=t,g.d=function(n,t,e){g.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:e})},g.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},g.t=function(n,t){if(1&t&&(n=g(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(g.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var I in n)g.d(e,I,function(t){return n[t]}.bind(null,I));return e},g.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return g.d(t,"a",t),t},g.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},g.p="",g(g.s=1)}({0:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export dissableDeprecationWarnings */\n/* unused harmony export Kefir */\n/* unused harmony export Observable */\n/* unused harmony export Stream */\n/* unused harmony export Property */\n/* unused harmony export never */\n/* unused harmony export later */\n/* unused harmony export interval */\n/* unused harmony export sequentially */\n/* unused harmony export fromPoll */\n/* unused harmony export withInterval */\n/* unused harmony export fromCallback */\n/* unused harmony export fromNodeCallback */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return fromEvents; });\n/* unused harmony export stream */\n/* unused harmony export constant */\n/* unused harmony export constantError */\n/* unused harmony export fromPromise */\n/* unused harmony export fromESObservable */\n/* unused harmony export combine */\n/* unused harmony export zip */\n/* unused harmony export merge */\n/* unused harmony export concat */\n/* unused harmony export Pool */\n/* unused harmony export pool */\n/* unused harmony export repeat */\n/* unused harmony export staticLand */\n/*! Kefir.js v3.8.6\n *  https://github.com/kefirjs/kefir\n */\n\nfunction createObj(proto) {\n  var F = function () {};\n  F.prototype = proto;\n  return new F();\n}\n\nfunction extend(target /*, mixin1, mixin2...*/) {\n  var length = arguments.length,\n      i = void 0,\n      prop = void 0;\n  for (i = 1; i < length; i++) {\n    for (prop in arguments[i]) {\n      target[prop] = arguments[i][prop];\n    }\n  }\n  return target;\n}\n\nfunction inherit(Child, Parent /*, mixin1, mixin2...*/) {\n  var length = arguments.length,\n      i = void 0;\n  Child.prototype = createObj(Parent.prototype);\n  Child.prototype.constructor = Child;\n  for (i = 2; i < length; i++) {\n    extend(Child.prototype, arguments[i]);\n  }\n  return Child;\n}\n\nvar NOTHING = ['<nothing>'];\nvar END = 'end';\nvar VALUE = 'value';\nvar ERROR = 'error';\nvar ANY = 'any';\n\nfunction concat(a, b) {\n  var result = void 0,\n      length = void 0,\n      i = void 0,\n      j = void 0;\n  if (a.length === 0) {\n    return b;\n  }\n  if (b.length === 0) {\n    return a;\n  }\n  j = 0;\n  result = new Array(a.length + b.length);\n  length = a.length;\n  for (i = 0; i < length; i++, j++) {\n    result[j] = a[i];\n  }\n  length = b.length;\n  for (i = 0; i < length; i++, j++) {\n    result[j] = b[i];\n  }\n  return result;\n}\n\nfunction find(arr, value) {\n  var length = arr.length,\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    if (arr[i] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction findByPred(arr, pred) {\n  var length = arr.length,\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    if (pred(arr[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction cloneArray(input) {\n  var length = input.length,\n      result = new Array(length),\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    result[i] = input[i];\n  }\n  return result;\n}\n\nfunction remove(input, index) {\n  var length = input.length,\n      result = void 0,\n      i = void 0,\n      j = void 0;\n  if (index >= 0 && index < length) {\n    if (length === 1) {\n      return [];\n    } else {\n      result = new Array(length - 1);\n      for (i = 0, j = 0; i < length; i++) {\n        if (i !== index) {\n          result[j] = input[i];\n          j++;\n        }\n      }\n      return result;\n    }\n  } else {\n    return input;\n  }\n}\n\nfunction map(input, fn) {\n  var length = input.length,\n      result = new Array(length),\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    result[i] = fn(input[i]);\n  }\n  return result;\n}\n\nfunction forEach(arr, fn) {\n  var length = arr.length,\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    fn(arr[i]);\n  }\n}\n\nfunction fillArray(arr, value) {\n  var length = arr.length,\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    arr[i] = value;\n  }\n}\n\nfunction contains(arr, value) {\n  return find(arr, value) !== -1;\n}\n\nfunction slide(cur, next, max) {\n  var length = Math.min(max, cur.length + 1),\n      offset = cur.length - length + 1,\n      result = new Array(length),\n      i = void 0;\n  for (i = offset; i < length; i++) {\n    result[i - offset] = cur[i];\n  }\n  result[length - 1] = next;\n  return result;\n}\n\nfunction callSubscriber(type, fn, event) {\n  if (type === ANY) {\n    fn(event);\n  } else if (type === event.type) {\n    if (type === VALUE || type === ERROR) {\n      fn(event.value);\n    } else {\n      fn();\n    }\n  }\n}\n\nfunction Dispatcher() {\n  this._items = [];\n  this._spies = [];\n  this._inLoop = 0;\n  this._removedItems = null;\n}\n\nextend(Dispatcher.prototype, {\n  add: function (type, fn) {\n    this._items = concat(this._items, [{ type: type, fn: fn }]);\n    return this._items.length;\n  },\n  remove: function (type, fn) {\n    var index = findByPred(this._items, function (x) {\n      return x.type === type && x.fn === fn;\n    });\n\n    // if we're currently in a notification loop,\n    // remember this subscriber was removed\n    if (this._inLoop !== 0 && index !== -1) {\n      if (this._removedItems === null) {\n        this._removedItems = [];\n      }\n      this._removedItems.push(this._items[index]);\n    }\n\n    this._items = remove(this._items, index);\n    return this._items.length;\n  },\n  addSpy: function (fn) {\n    this._spies = concat(this._spies, [fn]);\n    return this._spies.length;\n  },\n\n\n  // Because spies are only ever a function that perform logging as\n  // their only side effect, we don't need the same complicated\n  // removal logic like in remove()\n  removeSpy: function (fn) {\n    this._spies = remove(this._spies, this._spies.indexOf(fn));\n    return this._spies.length;\n  },\n  dispatch: function (event) {\n    this._inLoop++;\n    for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {\n      spies[i](event);\n    }\n\n    for (var _i = 0, items = this._items; _i < items.length; _i++) {\n      // cleanup was called\n      if (this._items === null) {\n        break;\n      }\n\n      // this subscriber was removed\n      if (this._removedItems !== null && contains(this._removedItems, items[_i])) {\n        continue;\n      }\n\n      callSubscriber(items[_i].type, items[_i].fn, event);\n    }\n    this._inLoop--;\n    if (this._inLoop === 0) {\n      this._removedItems = null;\n    }\n  },\n  cleanup: function () {\n    this._items = null;\n    this._spies = null;\n  }\n});\n\nfunction Observable() {\n  this._dispatcher = new Dispatcher();\n  this._active = false;\n  this._alive = true;\n  this._activating = false;\n  this._logHandlers = null;\n  this._spyHandlers = null;\n}\n\nextend(Observable.prototype, {\n  _name: 'observable',\n\n  _onActivation: function () {},\n  _onDeactivation: function () {},\n  _setActive: function (active) {\n    if (this._active !== active) {\n      this._active = active;\n      if (active) {\n        this._activating = true;\n        this._onActivation();\n        this._activating = false;\n      } else {\n        this._onDeactivation();\n      }\n    }\n  },\n  _clear: function () {\n    this._setActive(false);\n    this._dispatcher.cleanup();\n    this._dispatcher = null;\n    this._logHandlers = null;\n  },\n  _emit: function (type, x) {\n    switch (type) {\n      case VALUE:\n        return this._emitValue(x);\n      case ERROR:\n        return this._emitError(x);\n      case END:\n        return this._emitEnd();\n    }\n  },\n  _emitValue: function (value) {\n    if (this._alive) {\n      this._dispatcher.dispatch({ type: VALUE, value: value });\n    }\n  },\n  _emitError: function (value) {\n    if (this._alive) {\n      this._dispatcher.dispatch({ type: ERROR, value: value });\n    }\n  },\n  _emitEnd: function () {\n    if (this._alive) {\n      this._alive = false;\n      this._dispatcher.dispatch({ type: END });\n      this._clear();\n    }\n  },\n  _on: function (type, fn) {\n    if (this._alive) {\n      this._dispatcher.add(type, fn);\n      this._setActive(true);\n    } else {\n      callSubscriber(type, fn, { type: END });\n    }\n    return this;\n  },\n  _off: function (type, fn) {\n    if (this._alive) {\n      var count = this._dispatcher.remove(type, fn);\n      if (count === 0) {\n        this._setActive(false);\n      }\n    }\n    return this;\n  },\n  onValue: function (fn) {\n    return this._on(VALUE, fn);\n  },\n  onError: function (fn) {\n    return this._on(ERROR, fn);\n  },\n  onEnd: function (fn) {\n    return this._on(END, fn);\n  },\n  onAny: function (fn) {\n    return this._on(ANY, fn);\n  },\n  offValue: function (fn) {\n    return this._off(VALUE, fn);\n  },\n  offError: function (fn) {\n    return this._off(ERROR, fn);\n  },\n  offEnd: function (fn) {\n    return this._off(END, fn);\n  },\n  offAny: function (fn) {\n    return this._off(ANY, fn);\n  },\n  observe: function (observerOrOnValue, onError, onEnd) {\n    var _this = this;\n    var closed = false;\n\n    var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? { value: observerOrOnValue, error: onError, end: onEnd } : observerOrOnValue;\n\n    var handler = function (event) {\n      if (event.type === END) {\n        closed = true;\n      }\n      if (event.type === VALUE && observer.value) {\n        observer.value(event.value);\n      } else if (event.type === ERROR && observer.error) {\n        observer.error(event.value);\n      } else if (event.type === END && observer.end) {\n        observer.end(event.value);\n      }\n    };\n\n    this.onAny(handler);\n\n    return {\n      unsubscribe: function () {\n        if (!closed) {\n          _this.offAny(handler);\n          closed = true;\n        }\n      },\n\n      get closed() {\n        return closed;\n      }\n    };\n  },\n\n\n  // A and B must be subclasses of Stream and Property (order doesn't matter)\n  _ofSameType: function (A, B) {\n    return A.prototype.getType() === this.getType() ? A : B;\n  },\n  setName: function (sourceObs /* optional */, selfName) {\n    this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;\n    return this;\n  },\n  log: function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n    var isCurrent = void 0;\n    var handler = function (event) {\n      var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';\n      if (event.type === END) {\n        console.log(name, type);\n      } else {\n        console.log(name, type, event.value);\n      }\n    };\n\n    if (this._alive) {\n      if (!this._logHandlers) {\n        this._logHandlers = [];\n      }\n      this._logHandlers.push({ name: name, handler: handler });\n    }\n\n    isCurrent = true;\n    this.onAny(handler);\n    isCurrent = false;\n\n    return this;\n  },\n  offLog: function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n    if (this._logHandlers) {\n      var handlerIndex = findByPred(this._logHandlers, function (obj) {\n        return obj.name === name;\n      });\n      if (handlerIndex !== -1) {\n        this.offAny(this._logHandlers[handlerIndex].handler);\n        this._logHandlers.splice(handlerIndex, 1);\n      }\n    }\n\n    return this;\n  },\n  spy: function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n    var handler = function (event) {\n      var type = '<' + event.type + '>';\n      if (event.type === END) {\n        console.log(name, type);\n      } else {\n        console.log(name, type, event.value);\n      }\n    };\n    if (this._alive) {\n      if (!this._spyHandlers) {\n        this._spyHandlers = [];\n      }\n      this._spyHandlers.push({ name: name, handler: handler });\n      this._dispatcher.addSpy(handler);\n    }\n    return this;\n  },\n  offSpy: function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n    if (this._spyHandlers) {\n      var handlerIndex = findByPred(this._spyHandlers, function (obj) {\n        return obj.name === name;\n      });\n      if (handlerIndex !== -1) {\n        this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);\n        this._spyHandlers.splice(handlerIndex, 1);\n      }\n    }\n    return this;\n  }\n});\n\n// extend() can't handle `toString` in IE8\nObservable.prototype.toString = function () {\n  return '[' + this._name + ']';\n};\n\nfunction Stream() {\n  Observable.call(this);\n}\n\ninherit(Stream, Observable, {\n  _name: 'stream',\n\n  getType: function () {\n    return 'stream';\n  }\n});\n\nfunction Property() {\n  Observable.call(this);\n  this._currentEvent = null;\n}\n\ninherit(Property, Observable, {\n  _name: 'property',\n\n  _emitValue: function (value) {\n    if (this._alive) {\n      this._currentEvent = { type: VALUE, value: value };\n      if (!this._activating) {\n        this._dispatcher.dispatch({ type: VALUE, value: value });\n      }\n    }\n  },\n  _emitError: function (value) {\n    if (this._alive) {\n      this._currentEvent = { type: ERROR, value: value };\n      if (!this._activating) {\n        this._dispatcher.dispatch({ type: ERROR, value: value });\n      }\n    }\n  },\n  _emitEnd: function () {\n    if (this._alive) {\n      this._alive = false;\n      if (!this._activating) {\n        this._dispatcher.dispatch({ type: END });\n      }\n      this._clear();\n    }\n  },\n  _on: function (type, fn) {\n    if (this._alive) {\n      this._dispatcher.add(type, fn);\n      this._setActive(true);\n    }\n    if (this._currentEvent !== null) {\n      callSubscriber(type, fn, this._currentEvent);\n    }\n    if (!this._alive) {\n      callSubscriber(type, fn, { type: END });\n    }\n    return this;\n  },\n  getType: function () {\n    return 'property';\n  }\n});\n\nvar neverS = new Stream();\nneverS._emitEnd();\nneverS._name = 'never';\n\nfunction never() {\n  return neverS;\n}\n\nfunction timeBased(mixin) {\n  function AnonymousStream(wait, options) {\n    var _this = this;\n\n    Stream.call(this);\n    this._wait = wait;\n    this._intervalId = null;\n    this._$onTick = function () {\n      return _this._onTick();\n    };\n    this._init(options);\n  }\n\n  inherit(AnonymousStream, Stream, {\n    _init: function () {},\n    _free: function () {},\n    _onTick: function () {},\n    _onActivation: function () {\n      this._intervalId = setInterval(this._$onTick, this._wait);\n    },\n    _onDeactivation: function () {\n      if (this._intervalId !== null) {\n        clearInterval(this._intervalId);\n        this._intervalId = null;\n      }\n    },\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._$onTick = null;\n      this._free();\n    }\n  }, mixin);\n\n  return AnonymousStream;\n}\n\nvar S = timeBased({\n  _name: 'later',\n\n  _init: function (_ref) {\n    var x = _ref.x;\n\n    this._x = x;\n  },\n  _free: function () {\n    this._x = null;\n  },\n  _onTick: function () {\n    this._emitValue(this._x);\n    this._emitEnd();\n  }\n});\n\nfunction later(wait, x) {\n  return new S(wait, { x: x });\n}\n\nvar S$1 = timeBased({\n  _name: 'interval',\n\n  _init: function (_ref) {\n    var x = _ref.x;\n\n    this._x = x;\n  },\n  _free: function () {\n    this._x = null;\n  },\n  _onTick: function () {\n    this._emitValue(this._x);\n  }\n});\n\nfunction interval(wait, x) {\n  return new S$1(wait, { x: x });\n}\n\nvar S$2 = timeBased({\n  _name: 'sequentially',\n\n  _init: function (_ref) {\n    var xs = _ref.xs;\n\n    this._xs = cloneArray(xs);\n  },\n  _free: function () {\n    this._xs = null;\n  },\n  _onTick: function () {\n    if (this._xs.length === 1) {\n      this._emitValue(this._xs[0]);\n      this._emitEnd();\n    } else {\n      this._emitValue(this._xs.shift());\n    }\n  }\n});\n\nfunction sequentially(wait, xs) {\n  return xs.length === 0 ? never() : new S$2(wait, { xs: xs });\n}\n\nvar S$3 = timeBased({\n  _name: 'fromPoll',\n\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _onTick: function () {\n    var fn = this._fn;\n    this._emitValue(fn());\n  }\n});\n\nfunction fromPoll(wait, fn) {\n  return new S$3(wait, { fn: fn });\n}\n\nfunction emitter(obs) {\n  function value(x) {\n    obs._emitValue(x);\n    return obs._active;\n  }\n\n  function error(x) {\n    obs._emitError(x);\n    return obs._active;\n  }\n\n  function end() {\n    obs._emitEnd();\n    return obs._active;\n  }\n\n  function event(e) {\n    obs._emit(e.type, e.value);\n    return obs._active;\n  }\n\n  return {\n    value: value,\n    error: error,\n    end: end,\n    event: event,\n\n    // legacy\n    emit: value,\n    emitEvent: event\n  };\n}\n\nvar S$4 = timeBased({\n  _name: 'withInterval',\n\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n    this._emitter = emitter(this);\n  },\n  _free: function () {\n    this._fn = null;\n    this._emitter = null;\n  },\n  _onTick: function () {\n    var fn = this._fn;\n    fn(this._emitter);\n  }\n});\n\nfunction withInterval(wait, fn) {\n  return new S$4(wait, { fn: fn });\n}\n\nfunction S$5(fn) {\n  Stream.call(this);\n  this._fn = fn;\n  this._unsubscribe = null;\n}\n\ninherit(S$5, Stream, {\n  _name: 'stream',\n\n  _onActivation: function () {\n    var fn = this._fn;\n    var unsubscribe = fn(emitter(this));\n    this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;\n\n    // fix https://github.com/kefirjs/kefir/issues/35\n    if (!this._active) {\n      this._callUnsubscribe();\n    }\n  },\n  _callUnsubscribe: function () {\n    if (this._unsubscribe !== null) {\n      this._unsubscribe();\n      this._unsubscribe = null;\n    }\n  },\n  _onDeactivation: function () {\n    this._callUnsubscribe();\n  },\n  _clear: function () {\n    Stream.prototype._clear.call(this);\n    this._fn = null;\n  }\n});\n\nfunction stream(fn) {\n  return new S$5(fn);\n}\n\nfunction fromCallback(callbackConsumer) {\n  var called = false;\n\n  return stream(function (emitter) {\n    if (!called) {\n      callbackConsumer(function (x) {\n        emitter.emit(x);\n        emitter.end();\n      });\n      called = true;\n    }\n  }).setName('fromCallback');\n}\n\nfunction fromNodeCallback(callbackConsumer) {\n  var called = false;\n\n  return stream(function (emitter) {\n    if (!called) {\n      callbackConsumer(function (error, x) {\n        if (error) {\n          emitter.error(error);\n        } else {\n          emitter.emit(x);\n        }\n        emitter.end();\n      });\n      called = true;\n    }\n  }).setName('fromNodeCallback');\n}\n\nfunction spread(fn, length) {\n  switch (length) {\n    case 0:\n      return function () {\n        return fn();\n      };\n    case 1:\n      return function (a) {\n        return fn(a[0]);\n      };\n    case 2:\n      return function (a) {\n        return fn(a[0], a[1]);\n      };\n    case 3:\n      return function (a) {\n        return fn(a[0], a[1], a[2]);\n      };\n    case 4:\n      return function (a) {\n        return fn(a[0], a[1], a[2], a[3]);\n      };\n    default:\n      return function (a) {\n        return fn.apply(null, a);\n      };\n  }\n}\n\nfunction apply(fn, c, a) {\n  var aLength = a ? a.length : 0;\n  if (c == null) {\n    switch (aLength) {\n      case 0:\n        return fn();\n      case 1:\n        return fn(a[0]);\n      case 2:\n        return fn(a[0], a[1]);\n      case 3:\n        return fn(a[0], a[1], a[2]);\n      case 4:\n        return fn(a[0], a[1], a[2], a[3]);\n      default:\n        return fn.apply(null, a);\n    }\n  } else {\n    switch (aLength) {\n      case 0:\n        return fn.call(c);\n      default:\n        return fn.apply(c, a);\n    }\n  }\n}\n\nfunction fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {\n  return stream(function (emitter) {\n    var handler = transformer ? function () {\n      emitter.emit(apply(transformer, this, arguments));\n    } : function (x) {\n      emitter.emit(x);\n    };\n\n    sub(handler);\n    return function () {\n      return unsub(handler);\n    };\n  }).setName('fromSubUnsub');\n}\n\nvar pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];\n\nfunction fromEvents(target, eventName, transformer) {\n  var sub = void 0,\n      unsub = void 0;\n\n  for (var i = 0; i < pairs.length; i++) {\n    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {\n      sub = pairs[i][0];\n      unsub = pairs[i][1];\n      break;\n    }\n  }\n\n  if (sub === undefined) {\n    throw new Error(\"target don't support any of \" + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');\n  }\n\n  return fromSubUnsub(function (handler) {\n    return target[sub](eventName, handler);\n  }, function (handler) {\n    return target[unsub](eventName, handler);\n  }, transformer).setName('fromEvents');\n}\n\n// HACK:\n//   We don't call parent Class constructor, but instead putting all necessary\n//   properties into prototype to simulate ended Property\n//   (see Propperty and Observable classes).\n\nfunction P(value) {\n  this._currentEvent = { type: 'value', value: value, current: true };\n}\n\ninherit(P, Property, {\n  _name: 'constant',\n  _active: false,\n  _activating: false,\n  _alive: false,\n  _dispatcher: null,\n  _logHandlers: null\n});\n\nfunction constant(x) {\n  return new P(x);\n}\n\n// HACK:\n//   We don't call parent Class constructor, but instead putting all necessary\n//   properties into prototype to simulate ended Property\n//   (see Propperty and Observable classes).\n\nfunction P$1(value) {\n  this._currentEvent = { type: 'error', value: value, current: true };\n}\n\ninherit(P$1, Property, {\n  _name: 'constantError',\n  _active: false,\n  _activating: false,\n  _alive: false,\n  _dispatcher: null,\n  _logHandlers: null\n});\n\nfunction constantError(x) {\n  return new P$1(x);\n}\n\nfunction createConstructor(BaseClass, name) {\n  return function AnonymousObservable(source, options) {\n    var _this = this;\n\n    BaseClass.call(this);\n    this._source = source;\n    this._name = source._name + '.' + name;\n    this._init(options);\n    this._$handleAny = function (event) {\n      return _this._handleAny(event);\n    };\n  };\n}\n\nfunction createClassMethods(BaseClass) {\n  return {\n    _init: function () {},\n    _free: function () {},\n    _handleValue: function (x) {\n      this._emitValue(x);\n    },\n    _handleError: function (x) {\n      this._emitError(x);\n    },\n    _handleEnd: function () {\n      this._emitEnd();\n    },\n    _handleAny: function (event) {\n      switch (event.type) {\n        case VALUE:\n          return this._handleValue(event.value);\n        case ERROR:\n          return this._handleError(event.value);\n        case END:\n          return this._handleEnd();\n      }\n    },\n    _onActivation: function () {\n      this._source.onAny(this._$handleAny);\n    },\n    _onDeactivation: function () {\n      this._source.offAny(this._$handleAny);\n    },\n    _clear: function () {\n      BaseClass.prototype._clear.call(this);\n      this._source = null;\n      this._$handleAny = null;\n      this._free();\n    }\n  };\n}\n\nfunction createStream(name, mixin) {\n  var S = createConstructor(Stream, name);\n  inherit(S, Stream, createClassMethods(Stream), mixin);\n  return S;\n}\n\nfunction createProperty(name, mixin) {\n  var P = createConstructor(Property, name);\n  inherit(P, Property, createClassMethods(Property), mixin);\n  return P;\n}\n\nvar P$2 = createProperty('toProperty', {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._getInitialCurrent = fn;\n  },\n  _onActivation: function () {\n    if (this._getInitialCurrent !== null) {\n      var getInitial = this._getInitialCurrent;\n      this._emitValue(getInitial());\n    }\n    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n  }\n});\n\nfunction toProperty(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (fn !== null && typeof fn !== 'function') {\n    throw new Error('You should call toProperty() with a function or no arguments.');\n  }\n  return new P$2(obs, { fn: fn });\n}\n\nvar S$6 = createStream('changes', {\n  _handleValue: function (x) {\n    if (!this._activating) {\n      this._emitValue(x);\n    }\n  },\n  _handleError: function (x) {\n    if (!this._activating) {\n      this._emitError(x);\n    }\n  }\n});\n\nfunction changes(obs) {\n  return new S$6(obs);\n}\n\nfunction fromPromise(promise) {\n  var called = false;\n\n  var result = stream(function (emitter) {\n    if (!called) {\n      var onValue = function (x) {\n        emitter.emit(x);\n        emitter.end();\n      };\n      var onError = function (x) {\n        emitter.error(x);\n        emitter.end();\n      };\n      var _promise = promise.then(onValue, onError);\n\n      // prevent libraries like 'Q' or 'when' from swallowing exceptions\n      if (_promise && typeof _promise.done === 'function') {\n        _promise.done();\n      }\n\n      called = true;\n    }\n  });\n\n  return toProperty(result, null).setName('fromPromise');\n}\n\nfunction getGlodalPromise() {\n  if (typeof Promise === 'function') {\n    return Promise;\n  } else {\n    throw new Error(\"There isn't default Promise, use shim or parameter\");\n  }\n}\n\nvar toPromise = function (obs) {\n  var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();\n\n  var last = null;\n  return new Promise(function (resolve, reject) {\n    obs.onAny(function (event) {\n      if (event.type === END && last !== null) {\n        (last.type === VALUE ? resolve : reject)(last.value);\n        last = null;\n      } else {\n        last = event;\n      }\n    });\n  });\n};\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\n\n\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar ponyfill = createCommonjsModule(function (module, exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n}\n});\n\nvar index$1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n\n\nvar _ponyfill2 = _interopRequireDefault(ponyfill);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { 'default': obj };\n}\n\nvar root; /* global window */\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof commonjsGlobal !== 'undefined') {\n  root = commonjsGlobal;\n} else {\n  root = module;\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n});\n\nvar index = index$1;\n\n// this file contains some hot JS modules systems stuff\n\nvar $$observable = index.default ? index.default : index;\n\nfunction fromESObservable(_observable) {\n  var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;\n  return stream(function (emitter) {\n    var unsub = observable.subscribe({\n      error: function (error) {\n        emitter.error(error);\n        emitter.end();\n      },\n      next: function (value) {\n        emitter.emit(value);\n      },\n      complete: function () {\n        emitter.end();\n      }\n    });\n\n    if (unsub.unsubscribe) {\n      return function () {\n        unsub.unsubscribe();\n      };\n    } else {\n      return unsub;\n    }\n  }).setName('fromESObservable');\n}\n\nfunction ESObservable(observable) {\n  this._observable = observable.takeErrors(1);\n}\n\nextend(ESObservable.prototype, {\n  subscribe: function (observerOrOnNext, onError, onComplete) {\n    var _this = this;\n\n    var observer = typeof observerOrOnNext === 'function' ? { next: observerOrOnNext, error: onError, complete: onComplete } : observerOrOnNext;\n\n    var fn = function (event) {\n      if (event.type === END) {\n        closed = true;\n      }\n\n      if (event.type === VALUE && observer.next) {\n        observer.next(event.value);\n      } else if (event.type === ERROR && observer.error) {\n        observer.error(event.value);\n      } else if (event.type === END && observer.complete) {\n        observer.complete(event.value);\n      }\n    };\n\n    this._observable.onAny(fn);\n    var closed = false;\n\n    var subscription = {\n      unsubscribe: function () {\n        closed = true;\n        _this._observable.offAny(fn);\n      },\n      get closed() {\n        return closed;\n      }\n    };\n    return subscription;\n  }\n});\n\n// Need to assign directly b/c Symbols aren't enumerable.\nESObservable.prototype[$$observable] = function () {\n  return this;\n};\n\nfunction toESObservable() {\n  return new ESObservable(this);\n}\n\nfunction collect(source, keys, values) {\n  for (var prop in source) {\n    if (source.hasOwnProperty(prop)) {\n      keys.push(prop);\n      values.push(source[prop]);\n    }\n  }\n}\n\nfunction defaultErrorsCombinator(errors) {\n  var latestError = void 0;\n  for (var i = 0; i < errors.length; i++) {\n    if (errors[i] !== undefined) {\n      if (latestError === undefined || latestError.index < errors[i].index) {\n        latestError = errors[i];\n      }\n    }\n  }\n  return latestError.error;\n}\n\nfunction Combine(active, passive, combinator) {\n  var _this = this;\n\n  Stream.call(this);\n  this._activeCount = active.length;\n  this._sources = concat(active, passive);\n  this._combinator = combinator;\n  this._aliveCount = 0;\n  this._latestValues = new Array(this._sources.length);\n  this._latestErrors = new Array(this._sources.length);\n  fillArray(this._latestValues, NOTHING);\n  this._emitAfterActivation = false;\n  this._endAfterActivation = false;\n  this._latestErrorIndex = 0;\n\n  this._$handlers = [];\n\n  var _loop = function (i) {\n    _this._$handlers.push(function (event) {\n      return _this._handleAny(i, event);\n    });\n  };\n\n  for (var i = 0; i < this._sources.length; i++) {\n    _loop(i);\n  }\n}\n\ninherit(Combine, Stream, {\n  _name: 'combine',\n\n  _onActivation: function () {\n    this._aliveCount = this._activeCount;\n\n    // we need to suscribe to _passive_ sources before _active_\n    // (see https://github.com/kefirjs/kefir/issues/98)\n    for (var i = this._activeCount; i < this._sources.length; i++) {\n      this._sources[i].onAny(this._$handlers[i]);\n    }\n    for (var _i = 0; _i < this._activeCount; _i++) {\n      this._sources[_i].onAny(this._$handlers[_i]);\n    }\n\n    if (this._emitAfterActivation) {\n      this._emitAfterActivation = false;\n      this._emitIfFull();\n    }\n    if (this._endAfterActivation) {\n      this._emitEnd();\n    }\n  },\n  _onDeactivation: function () {\n    var length = this._sources.length,\n        i = void 0;\n    for (i = 0; i < length; i++) {\n      this._sources[i].offAny(this._$handlers[i]);\n    }\n  },\n  _emitIfFull: function () {\n    var hasAllValues = true;\n    var hasErrors = false;\n    var length = this._latestValues.length;\n    var valuesCopy = new Array(length);\n    var errorsCopy = new Array(length);\n\n    for (var i = 0; i < length; i++) {\n      valuesCopy[i] = this._latestValues[i];\n      errorsCopy[i] = this._latestErrors[i];\n\n      if (valuesCopy[i] === NOTHING) {\n        hasAllValues = false;\n      }\n\n      if (errorsCopy[i] !== undefined) {\n        hasErrors = true;\n      }\n    }\n\n    if (hasAllValues) {\n      var combinator = this._combinator;\n      this._emitValue(combinator(valuesCopy));\n    }\n    if (hasErrors) {\n      this._emitError(defaultErrorsCombinator(errorsCopy));\n    }\n  },\n  _handleAny: function (i, event) {\n    if (event.type === VALUE || event.type === ERROR) {\n      if (event.type === VALUE) {\n        this._latestValues[i] = event.value;\n        this._latestErrors[i] = undefined;\n      }\n      if (event.type === ERROR) {\n        this._latestValues[i] = NOTHING;\n        this._latestErrors[i] = {\n          index: this._latestErrorIndex++,\n          error: event.value\n        };\n      }\n\n      if (i < this._activeCount) {\n        if (this._activating) {\n          this._emitAfterActivation = true;\n        } else {\n          this._emitIfFull();\n        }\n      }\n    } else {\n      // END\n\n      if (i < this._activeCount) {\n        this._aliveCount--;\n        if (this._aliveCount === 0) {\n          if (this._activating) {\n            this._endAfterActivation = true;\n          } else {\n            this._emitEnd();\n          }\n        }\n      }\n    }\n  },\n  _clear: function () {\n    Stream.prototype._clear.call(this);\n    this._sources = null;\n    this._latestValues = null;\n    this._latestErrors = null;\n    this._combinator = null;\n    this._$handlers = null;\n  }\n});\n\nfunction combineAsArray(active) {\n  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var combinator = arguments[2];\n\n  if (!Array.isArray(passive)) {\n    throw new Error('Combine can only combine active and passive collections of the same type.');\n  }\n\n  combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {\n    return x;\n  };\n  return active.length === 0 ? never() : new Combine(active, passive, combinator);\n}\n\nfunction combineAsObject(active) {\n  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var combinator = arguments[2];\n\n  if (typeof passive !== 'object' || Array.isArray(passive)) {\n    throw new Error('Combine can only combine active and passive collections of the same type.');\n  }\n\n  var keys = [],\n      activeObservables = [],\n      passiveObservables = [];\n\n  collect(active, keys, activeObservables);\n  collect(passive, keys, passiveObservables);\n\n  var objectify = function (values) {\n    var event = {};\n    for (var i = values.length - 1; 0 <= i; i--) {\n      event[keys[i]] = values[i];\n    }\n    return combinator ? combinator(event) : event;\n  };\n\n  return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);\n}\n\nfunction combine(active, passive, combinator) {\n  if (typeof passive === 'function') {\n    combinator = passive;\n    passive = undefined;\n  }\n\n  return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);\n}\n\nvar Observable$2 = {\n  empty: function () {\n    return never();\n  },\n\n\n  // Monoid based on merge() seems more useful than one based on concat().\n  concat: function (a, b) {\n    return a.merge(b);\n  },\n  of: function (x) {\n    return constant(x);\n  },\n  map: function (fn, obs) {\n    return obs.map(fn);\n  },\n  bimap: function (fnErr, fnVal, obs) {\n    return obs.mapErrors(fnErr).map(fnVal);\n  },\n\n\n  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get\n  // different (not very useful) behavior. But spec requires that if method can be derived\n  // it must have the same behavior as hand-written method. We intentionally violate the spec\n  // in hope that it won't cause many troubles in practice. And in return we have more useful type.\n  ap: function (obsFn, obsVal) {\n    return combine([obsFn, obsVal], function (fn, val) {\n      return fn(val);\n    });\n  },\n  chain: function (fn, obs) {\n    return obs.flatMap(fn);\n  }\n};\n\n\n\nvar staticLand = Object.freeze({\n\tObservable: Observable$2\n});\n\nvar mixin = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    this._emitValue(fn(x));\n  }\n};\n\nvar S$7 = createStream('map', mixin);\nvar P$3 = createProperty('map', mixin);\n\nvar id = function (x) {\n  return x;\n};\n\nfunction map$1(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;\n\n  return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });\n}\n\nvar mixin$1 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    if (fn(x)) {\n      this._emitValue(x);\n    }\n  }\n};\n\nvar S$8 = createStream('filter', mixin$1);\nvar P$4 = createProperty('filter', mixin$1);\n\nvar id$1 = function (x) {\n  return x;\n};\n\nfunction filter(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;\n\n  return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });\n}\n\nvar mixin$2 = {\n  _init: function (_ref) {\n    var n = _ref.n;\n\n    this._n = n;\n    if (n <= 0) {\n      this._emitEnd();\n    }\n  },\n  _handleValue: function (x) {\n    if (this._n === 0) {\n      return;\n    }\n    this._n--;\n    this._emitValue(x);\n    if (this._n === 0) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$9 = createStream('take', mixin$2);\nvar P$5 = createProperty('take', mixin$2);\n\nfunction take(obs, n) {\n  return new (obs._ofSameType(S$9, P$5))(obs, { n: n });\n}\n\nvar mixin$3 = {\n  _init: function (_ref) {\n    var n = _ref.n;\n\n    this._n = n;\n    if (n <= 0) {\n      this._emitEnd();\n    }\n  },\n  _handleError: function (x) {\n    if (this._n === 0) {\n      return;\n    }\n    this._n--;\n    this._emitError(x);\n    if (this._n === 0) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$10 = createStream('takeErrors', mixin$3);\nvar P$6 = createProperty('takeErrors', mixin$3);\n\nfunction takeErrors(obs, n) {\n  return new (obs._ofSameType(S$10, P$6))(obs, { n: n });\n}\n\nvar mixin$4 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    if (fn(x)) {\n      this._emitValue(x);\n    } else {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$11 = createStream('takeWhile', mixin$4);\nvar P$7 = createProperty('takeWhile', mixin$4);\n\nvar id$2 = function (x) {\n  return x;\n};\n\nfunction takeWhile(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;\n\n  return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });\n}\n\nvar mixin$5 = {\n  _init: function () {\n    this._lastValue = NOTHING;\n  },\n  _free: function () {\n    this._lastValue = null;\n  },\n  _handleValue: function (x) {\n    this._lastValue = x;\n  },\n  _handleEnd: function () {\n    if (this._lastValue !== NOTHING) {\n      this._emitValue(this._lastValue);\n    }\n    this._emitEnd();\n  }\n};\n\nvar S$12 = createStream('last', mixin$5);\nvar P$8 = createProperty('last', mixin$5);\n\nfunction last(obs) {\n  return new (obs._ofSameType(S$12, P$8))(obs);\n}\n\nvar mixin$6 = {\n  _init: function (_ref) {\n    var n = _ref.n;\n\n    this._n = Math.max(0, n);\n  },\n  _handleValue: function (x) {\n    if (this._n === 0) {\n      this._emitValue(x);\n    } else {\n      this._n--;\n    }\n  }\n};\n\nvar S$13 = createStream('skip', mixin$6);\nvar P$9 = createProperty('skip', mixin$6);\n\nfunction skip(obs, n) {\n  return new (obs._ofSameType(S$13, P$9))(obs, { n: n });\n}\n\nvar mixin$7 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    if (this._fn !== null && !fn(x)) {\n      this._fn = null;\n    }\n    if (this._fn === null) {\n      this._emitValue(x);\n    }\n  }\n};\n\nvar S$14 = createStream('skipWhile', mixin$7);\nvar P$10 = createProperty('skipWhile', mixin$7);\n\nvar id$3 = function (x) {\n  return x;\n};\n\nfunction skipWhile(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;\n\n  return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });\n}\n\nvar mixin$8 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n    this._prev = NOTHING;\n  },\n  _free: function () {\n    this._fn = null;\n    this._prev = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    if (this._prev === NOTHING || !fn(this._prev, x)) {\n      this._prev = x;\n      this._emitValue(x);\n    }\n  }\n};\n\nvar S$15 = createStream('skipDuplicates', mixin$8);\nvar P$11 = createProperty('skipDuplicates', mixin$8);\n\nvar eq = function (a, b) {\n  return a === b;\n};\n\nfunction skipDuplicates(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;\n\n  return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });\n}\n\nvar mixin$9 = {\n  _init: function (_ref) {\n    var fn = _ref.fn,\n        seed = _ref.seed;\n\n    this._fn = fn;\n    this._prev = seed;\n  },\n  _free: function () {\n    this._prev = null;\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    if (this._prev !== NOTHING) {\n      var fn = this._fn;\n      this._emitValue(fn(this._prev, x));\n    }\n    this._prev = x;\n  }\n};\n\nvar S$16 = createStream('diff', mixin$9);\nvar P$12 = createProperty('diff', mixin$9);\n\nfunction defaultFn(a, b) {\n  return [a, b];\n}\n\nfunction diff(obs, fn) {\n  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n\n  return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });\n}\n\nvar P$13 = createProperty('scan', {\n  _init: function (_ref) {\n    var fn = _ref.fn,\n        seed = _ref.seed;\n\n    this._fn = fn;\n    this._seed = seed;\n    if (seed !== NOTHING) {\n      this._emitValue(seed);\n    }\n  },\n  _free: function () {\n    this._fn = null;\n    this._seed = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    if (this._currentEvent === null || this._currentEvent.type === ERROR) {\n      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));\n    } else {\n      this._emitValue(fn(this._currentEvent.value, x));\n    }\n  }\n});\n\nfunction scan(obs, fn) {\n  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n\n  return new P$13(obs, { fn: fn, seed: seed });\n}\n\nvar mixin$10 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    var xs = fn(x);\n    for (var i = 0; i < xs.length; i++) {\n      this._emitValue(xs[i]);\n    }\n  }\n};\n\nvar S$17 = createStream('flatten', mixin$10);\n\nvar id$4 = function (x) {\n  return x;\n};\n\nfunction flatten(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;\n\n  return new S$17(obs, { fn: fn });\n}\n\nvar END_MARKER = {};\n\nvar mixin$11 = {\n  _init: function (_ref) {\n    var _this = this;\n\n    var wait = _ref.wait;\n\n    this._wait = Math.max(0, wait);\n    this._buff = [];\n    this._$shiftBuff = function () {\n      var value = _this._buff.shift();\n      if (value === END_MARKER) {\n        _this._emitEnd();\n      } else {\n        _this._emitValue(value);\n      }\n    };\n  },\n  _free: function () {\n    this._buff = null;\n    this._$shiftBuff = null;\n  },\n  _handleValue: function (x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      this._buff.push(x);\n      setTimeout(this._$shiftBuff, this._wait);\n    }\n  },\n  _handleEnd: function () {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      this._buff.push(END_MARKER);\n      setTimeout(this._$shiftBuff, this._wait);\n    }\n  }\n};\n\nvar S$18 = createStream('delay', mixin$11);\nvar P$14 = createProperty('delay', mixin$11);\n\nfunction delay(obs, wait) {\n  return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });\n}\n\nvar now = Date.now ? function () {\n  return Date.now();\n} : function () {\n  return new Date().getTime();\n};\n\nvar mixin$12 = {\n  _init: function (_ref) {\n    var _this = this;\n\n    var wait = _ref.wait,\n        leading = _ref.leading,\n        trailing = _ref.trailing;\n\n    this._wait = Math.max(0, wait);\n    this._leading = leading;\n    this._trailing = trailing;\n    this._trailingValue = null;\n    this._timeoutId = null;\n    this._endLater = false;\n    this._lastCallTime = 0;\n    this._$trailingCall = function () {\n      return _this._trailingCall();\n    };\n  },\n  _free: function () {\n    this._trailingValue = null;\n    this._$trailingCall = null;\n  },\n  _handleValue: function (x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      var curTime = now();\n      if (this._lastCallTime === 0 && !this._leading) {\n        this._lastCallTime = curTime;\n      }\n      var remaining = this._wait - (curTime - this._lastCallTime);\n      if (remaining <= 0) {\n        this._cancelTrailing();\n        this._lastCallTime = curTime;\n        this._emitValue(x);\n      } else if (this._trailing) {\n        this._cancelTrailing();\n        this._trailingValue = x;\n        this._timeoutId = setTimeout(this._$trailingCall, remaining);\n      }\n    }\n  },\n  _handleEnd: function () {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      if (this._timeoutId) {\n        this._endLater = true;\n      } else {\n        this._emitEnd();\n      }\n    }\n  },\n  _cancelTrailing: function () {\n    if (this._timeoutId !== null) {\n      clearTimeout(this._timeoutId);\n      this._timeoutId = null;\n    }\n  },\n  _trailingCall: function () {\n    this._emitValue(this._trailingValue);\n    this._timeoutId = null;\n    this._trailingValue = null;\n    this._lastCallTime = !this._leading ? 0 : now();\n    if (this._endLater) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$19 = createStream('throttle', mixin$12);\nvar P$15 = createProperty('throttle', mixin$12);\n\nfunction throttle(obs, wait) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref2$leading = _ref2.leading,\n      leading = _ref2$leading === undefined ? true : _ref2$leading,\n      _ref2$trailing = _ref2.trailing,\n      trailing = _ref2$trailing === undefined ? true : _ref2$trailing;\n\n  return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });\n}\n\nvar mixin$13 = {\n  _init: function (_ref) {\n    var _this = this;\n\n    var wait = _ref.wait,\n        immediate = _ref.immediate;\n\n    this._wait = Math.max(0, wait);\n    this._immediate = immediate;\n    this._lastAttempt = 0;\n    this._timeoutId = null;\n    this._laterValue = null;\n    this._endLater = false;\n    this._$later = function () {\n      return _this._later();\n    };\n  },\n  _free: function () {\n    this._laterValue = null;\n    this._$later = null;\n  },\n  _handleValue: function (x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      this._lastAttempt = now();\n      if (this._immediate && !this._timeoutId) {\n        this._emitValue(x);\n      }\n      if (!this._timeoutId) {\n        this._timeoutId = setTimeout(this._$later, this._wait);\n      }\n      if (!this._immediate) {\n        this._laterValue = x;\n      }\n    }\n  },\n  _handleEnd: function () {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      if (this._timeoutId && !this._immediate) {\n        this._endLater = true;\n      } else {\n        this._emitEnd();\n      }\n    }\n  },\n  _later: function () {\n    var last = now() - this._lastAttempt;\n    if (last < this._wait && last >= 0) {\n      this._timeoutId = setTimeout(this._$later, this._wait - last);\n    } else {\n      this._timeoutId = null;\n      if (!this._immediate) {\n        this._emitValue(this._laterValue);\n        this._laterValue = null;\n      }\n      if (this._endLater) {\n        this._emitEnd();\n      }\n    }\n  }\n};\n\nvar S$20 = createStream('debounce', mixin$13);\nvar P$16 = createProperty('debounce', mixin$13);\n\nfunction debounce(obs, wait) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref2$immediate = _ref2.immediate,\n      immediate = _ref2$immediate === undefined ? false : _ref2$immediate;\n\n  return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });\n}\n\nvar mixin$14 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleError: function (x) {\n    var fn = this._fn;\n    this._emitError(fn(x));\n  }\n};\n\nvar S$21 = createStream('mapErrors', mixin$14);\nvar P$17 = createProperty('mapErrors', mixin$14);\n\nvar id$5 = function (x) {\n  return x;\n};\n\nfunction mapErrors(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;\n\n  return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });\n}\n\nvar mixin$15 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleError: function (x) {\n    var fn = this._fn;\n    if (fn(x)) {\n      this._emitError(x);\n    }\n  }\n};\n\nvar S$22 = createStream('filterErrors', mixin$15);\nvar P$18 = createProperty('filterErrors', mixin$15);\n\nvar id$6 = function (x) {\n  return x;\n};\n\nfunction filterErrors(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;\n\n  return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });\n}\n\nvar mixin$16 = {\n  _handleValue: function () {}\n};\n\nvar S$23 = createStream('ignoreValues', mixin$16);\nvar P$19 = createProperty('ignoreValues', mixin$16);\n\nfunction ignoreValues(obs) {\n  return new (obs._ofSameType(S$23, P$19))(obs);\n}\n\nvar mixin$17 = {\n  _handleError: function () {}\n};\n\nvar S$24 = createStream('ignoreErrors', mixin$17);\nvar P$20 = createProperty('ignoreErrors', mixin$17);\n\nfunction ignoreErrors(obs) {\n  return new (obs._ofSameType(S$24, P$20))(obs);\n}\n\nvar mixin$18 = {\n  _handleEnd: function () {}\n};\n\nvar S$25 = createStream('ignoreEnd', mixin$18);\nvar P$21 = createProperty('ignoreEnd', mixin$18);\n\nfunction ignoreEnd(obs) {\n  return new (obs._ofSameType(S$25, P$21))(obs);\n}\n\nvar mixin$19 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleEnd: function () {\n    var fn = this._fn;\n    this._emitValue(fn());\n    this._emitEnd();\n  }\n};\n\nvar S$26 = createStream('beforeEnd', mixin$19);\nvar P$22 = createProperty('beforeEnd', mixin$19);\n\nfunction beforeEnd(obs, fn) {\n  return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });\n}\n\nvar mixin$20 = {\n  _init: function (_ref) {\n    var min = _ref.min,\n        max = _ref.max;\n\n    this._max = max;\n    this._min = min;\n    this._buff = [];\n  },\n  _free: function () {\n    this._buff = null;\n  },\n  _handleValue: function (x) {\n    this._buff = slide(this._buff, x, this._max);\n    if (this._buff.length >= this._min) {\n      this._emitValue(this._buff);\n    }\n  }\n};\n\nvar S$27 = createStream('slidingWindow', mixin$20);\nvar P$23 = createProperty('slidingWindow', mixin$20);\n\nfunction slidingWindow(obs, max) {\n  var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });\n}\n\nvar mixin$21 = {\n  _init: function (_ref) {\n    var fn = _ref.fn,\n        flushOnEnd = _ref.flushOnEnd;\n\n    this._fn = fn;\n    this._flushOnEnd = flushOnEnd;\n    this._buff = [];\n  },\n  _free: function () {\n    this._buff = null;\n  },\n  _flush: function () {\n    if (this._buff !== null && this._buff.length !== 0) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n  _handleValue: function (x) {\n    this._buff.push(x);\n    var fn = this._fn;\n    if (!fn(x)) {\n      this._flush();\n    }\n  },\n  _handleEnd: function () {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  }\n};\n\nvar S$28 = createStream('bufferWhile', mixin$21);\nvar P$24 = createProperty('bufferWhile', mixin$21);\n\nvar id$7 = function (x) {\n  return x;\n};\n\nfunction bufferWhile(obs, fn) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref2$flushOnEnd = _ref2.flushOnEnd,\n      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n  return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });\n}\n\nvar mixin$22 = {\n  _init: function (_ref) {\n    var count = _ref.count,\n        flushOnEnd = _ref.flushOnEnd;\n\n    this._count = count;\n    this._flushOnEnd = flushOnEnd;\n    this._buff = [];\n  },\n  _free: function () {\n    this._buff = null;\n  },\n  _flush: function () {\n    if (this._buff !== null && this._buff.length !== 0) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n  _handleValue: function (x) {\n    this._buff.push(x);\n    if (this._buff.length >= this._count) {\n      this._flush();\n    }\n  },\n  _handleEnd: function () {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  }\n};\n\nvar S$29 = createStream('bufferWithCount', mixin$22);\nvar P$25 = createProperty('bufferWithCount', mixin$22);\n\nfunction bufferWhile$1(obs, count) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref2$flushOnEnd = _ref2.flushOnEnd,\n      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n  return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });\n}\n\nvar mixin$23 = {\n  _init: function (_ref) {\n    var _this = this;\n\n    var wait = _ref.wait,\n        count = _ref.count,\n        flushOnEnd = _ref.flushOnEnd;\n\n    this._wait = wait;\n    this._count = count;\n    this._flushOnEnd = flushOnEnd;\n    this._intervalId = null;\n    this._$onTick = function () {\n      return _this._flush();\n    };\n    this._buff = [];\n  },\n  _free: function () {\n    this._$onTick = null;\n    this._buff = null;\n  },\n  _flush: function () {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n  _handleValue: function (x) {\n    this._buff.push(x);\n    if (this._buff.length >= this._count) {\n      clearInterval(this._intervalId);\n      this._flush();\n      this._intervalId = setInterval(this._$onTick, this._wait);\n    }\n  },\n  _handleEnd: function () {\n    if (this._flushOnEnd && this._buff.length !== 0) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n  _onActivation: function () {\n    this._intervalId = setInterval(this._$onTick, this._wait);\n    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n  },\n  _onDeactivation: function () {\n    if (this._intervalId !== null) {\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n    }\n    this._source.offAny(this._$handleAny); // copied from patterns/one-source\n  }\n};\n\nvar S$30 = createStream('bufferWithTimeOrCount', mixin$23);\nvar P$26 = createProperty('bufferWithTimeOrCount', mixin$23);\n\nfunction bufferWithTimeOrCount(obs, wait, count) {\n  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref2$flushOnEnd = _ref2.flushOnEnd,\n      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n  return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });\n}\n\nfunction xformForObs(obs) {\n  return {\n    '@@transducer/step': function (res, input) {\n      obs._emitValue(input);\n      return null;\n    },\n    '@@transducer/result': function () {\n      obs._emitEnd();\n      return null;\n    }\n  };\n}\n\nvar mixin$24 = {\n  _init: function (_ref) {\n    var transducer = _ref.transducer;\n\n    this._xform = transducer(xformForObs(this));\n  },\n  _free: function () {\n    this._xform = null;\n  },\n  _handleValue: function (x) {\n    if (this._xform['@@transducer/step'](null, x) !== null) {\n      this._xform['@@transducer/result'](null);\n    }\n  },\n  _handleEnd: function () {\n    this._xform['@@transducer/result'](null);\n  }\n};\n\nvar S$31 = createStream('transduce', mixin$24);\nvar P$27 = createProperty('transduce', mixin$24);\n\nfunction transduce(obs, transducer) {\n  return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });\n}\n\nvar mixin$25 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._handler = fn;\n    this._emitter = emitter(this);\n  },\n  _free: function () {\n    this._handler = null;\n    this._emitter = null;\n  },\n  _handleAny: function (event) {\n    this._handler(this._emitter, event);\n  }\n};\n\nvar S$32 = createStream('withHandler', mixin$25);\nvar P$28 = createProperty('withHandler', mixin$25);\n\nfunction withHandler(obs, fn) {\n  return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });\n}\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction Zip(sources, combinator) {\n  var _this = this;\n\n  Stream.call(this);\n\n  this._buffers = map(sources, function (source) {\n    return isArray(source) ? cloneArray(source) : [];\n  });\n  this._sources = map(sources, function (source) {\n    return isArray(source) ? never() : source;\n  });\n\n  this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n    return x;\n  };\n  this._aliveCount = 0;\n\n  this._$handlers = [];\n\n  var _loop = function (i) {\n    _this._$handlers.push(function (event) {\n      return _this._handleAny(i, event);\n    });\n  };\n\n  for (var i = 0; i < this._sources.length; i++) {\n    _loop(i);\n  }\n}\n\ninherit(Zip, Stream, {\n  _name: 'zip',\n\n  _onActivation: function () {\n    // if all sources are arrays\n    while (this._isFull()) {\n      this._emit();\n    }\n\n    var length = this._sources.length;\n    this._aliveCount = length;\n    for (var i = 0; i < length && this._active; i++) {\n      this._sources[i].onAny(this._$handlers[i]);\n    }\n  },\n  _onDeactivation: function () {\n    for (var i = 0; i < this._sources.length; i++) {\n      this._sources[i].offAny(this._$handlers[i]);\n    }\n  },\n  _emit: function () {\n    var values = new Array(this._buffers.length);\n    for (var i = 0; i < this._buffers.length; i++) {\n      values[i] = this._buffers[i].shift();\n    }\n    var combinator = this._combinator;\n    this._emitValue(combinator(values));\n  },\n  _isFull: function () {\n    for (var i = 0; i < this._buffers.length; i++) {\n      if (this._buffers[i].length === 0) {\n        return false;\n      }\n    }\n    return true;\n  },\n  _handleAny: function (i, event) {\n    if (event.type === VALUE) {\n      this._buffers[i].push(event.value);\n      if (this._isFull()) {\n        this._emit();\n      }\n    }\n    if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n    if (event.type === END) {\n      this._aliveCount--;\n      if (this._aliveCount === 0) {\n        this._emitEnd();\n      }\n    }\n  },\n  _clear: function () {\n    Stream.prototype._clear.call(this);\n    this._sources = null;\n    this._buffers = null;\n    this._combinator = null;\n    this._$handlers = null;\n  }\n});\n\nfunction zip(observables, combinator /* Function | falsey */) {\n  return observables.length === 0 ? never() : new Zip(observables, combinator);\n}\n\nvar id$8 = function (x) {\n  return x;\n};\n\nfunction AbstractPool() {\n  var _this = this;\n\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$queueLim = _ref.queueLim,\n      queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim,\n      _ref$concurLim = _ref.concurLim,\n      concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim,\n      _ref$drop = _ref.drop,\n      drop = _ref$drop === undefined ? 'new' : _ref$drop;\n\n  Stream.call(this);\n\n  this._queueLim = queueLim < 0 ? -1 : queueLim;\n  this._concurLim = concurLim < 0 ? -1 : concurLim;\n  this._drop = drop;\n  this._queue = [];\n  this._curSources = [];\n  this._$handleSubAny = function (event) {\n    return _this._handleSubAny(event);\n  };\n  this._$endHandlers = [];\n  this._currentlyAdding = null;\n\n  if (this._concurLim === 0) {\n    this._emitEnd();\n  }\n}\n\ninherit(AbstractPool, Stream, {\n  _name: 'abstractPool',\n\n  _add: function (obj, toObs /* Function | falsey */) {\n    toObs = toObs || id$8;\n    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {\n      this._addToCur(toObs(obj));\n    } else {\n      if (this._queueLim === -1 || this._queue.length < this._queueLim) {\n        this._addToQueue(toObs(obj));\n      } else if (this._drop === 'old') {\n        this._removeOldest();\n        this._add(obj, toObs);\n      }\n    }\n  },\n  _addAll: function (obss) {\n    var _this2 = this;\n\n    forEach(obss, function (obs) {\n      return _this2._add(obs);\n    });\n  },\n  _remove: function (obs) {\n    if (this._removeCur(obs) === -1) {\n      this._removeQueue(obs);\n    }\n  },\n  _addToQueue: function (obs) {\n    this._queue = concat(this._queue, [obs]);\n  },\n  _addToCur: function (obs) {\n    if (this._active) {\n      // HACK:\n      //\n      // We have two optimizations for cases when `obs` is ended. We don't want\n      // to add such observable to the list, but only want to emit events\n      // from it (if it has some).\n      //\n      // Instead of this hacks, we could just did following,\n      // but it would be 5-8 times slower:\n      //\n      //     this._curSources = concat(this._curSources, [obs]);\n      //     this._subscribe(obs);\n      //\n\n      // #1\n      // This one for cases when `obs` already ended\n      // e.g., Kefir.constant() or Kefir.never()\n      if (!obs._alive) {\n        if (obs._currentEvent) {\n          this._emit(obs._currentEvent.type, obs._currentEvent.value);\n        }\n        // The _emit above could have caused this stream to end.\n        if (this._active) {\n          if (this._queue.length !== 0) {\n            this._pullQueue();\n          } else if (this._curSources.length === 0) {\n            this._onEmpty();\n          }\n        }\n        return;\n      }\n\n      // #2\n      // This one is for cases when `obs` going to end synchronously on\n      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})\n      this._currentlyAdding = obs;\n      obs.onAny(this._$handleSubAny);\n      this._currentlyAdding = null;\n      if (obs._alive) {\n        this._curSources = concat(this._curSources, [obs]);\n        if (this._active) {\n          this._subToEnd(obs);\n        }\n      }\n    } else {\n      this._curSources = concat(this._curSources, [obs]);\n    }\n  },\n  _subToEnd: function (obs) {\n    var _this3 = this;\n\n    var onEnd = function () {\n      return _this3._removeCur(obs);\n    };\n    this._$endHandlers.push({ obs: obs, handler: onEnd });\n    obs.onEnd(onEnd);\n  },\n  _subscribe: function (obs) {\n    obs.onAny(this._$handleSubAny);\n\n    // it can become inactive in responce of subscribing to `obs.onAny` above\n    if (this._active) {\n      this._subToEnd(obs);\n    }\n  },\n  _unsubscribe: function (obs) {\n    obs.offAny(this._$handleSubAny);\n\n    var onEndI = findByPred(this._$endHandlers, function (obj) {\n      return obj.obs === obs;\n    });\n    if (onEndI !== -1) {\n      obs.offEnd(this._$endHandlers[onEndI].handler);\n      this._$endHandlers.splice(onEndI, 1);\n    }\n  },\n  _handleSubAny: function (event) {\n    if (event.type === VALUE) {\n      this._emitValue(event.value);\n    } else if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n  },\n  _removeQueue: function (obs) {\n    var index = find(this._queue, obs);\n    this._queue = remove(this._queue, index);\n    return index;\n  },\n  _removeCur: function (obs) {\n    if (this._active) {\n      this._unsubscribe(obs);\n    }\n    var index = find(this._curSources, obs);\n    this._curSources = remove(this._curSources, index);\n    if (index !== -1) {\n      if (this._queue.length !== 0) {\n        this._pullQueue();\n      } else if (this._curSources.length === 0) {\n        this._onEmpty();\n      }\n    }\n    return index;\n  },\n  _removeOldest: function () {\n    this._removeCur(this._curSources[0]);\n  },\n  _pullQueue: function () {\n    if (this._queue.length !== 0) {\n      this._queue = cloneArray(this._queue);\n      this._addToCur(this._queue.shift());\n    }\n  },\n  _onActivation: function () {\n    for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {\n      this._subscribe(sources[i]);\n    }\n  },\n  _onDeactivation: function () {\n    for (var i = 0, sources = this._curSources; i < sources.length; i++) {\n      this._unsubscribe(sources[i]);\n    }\n    if (this._currentlyAdding !== null) {\n      this._unsubscribe(this._currentlyAdding);\n    }\n  },\n  _isEmpty: function () {\n    return this._curSources.length === 0;\n  },\n  _onEmpty: function () {},\n  _clear: function () {\n    Stream.prototype._clear.call(this);\n    this._queue = null;\n    this._curSources = null;\n    this._$handleSubAny = null;\n    this._$endHandlers = null;\n  }\n});\n\nfunction Merge(sources) {\n  AbstractPool.call(this);\n  this._addAll(sources);\n  this._initialised = true;\n}\n\ninherit(Merge, AbstractPool, {\n  _name: 'merge',\n\n  _onEmpty: function () {\n    if (this._initialised) {\n      this._emitEnd();\n    }\n  }\n});\n\nfunction merge(observables) {\n  return observables.length === 0 ? never() : new Merge(observables);\n}\n\nfunction S$33(generator) {\n  var _this = this;\n\n  Stream.call(this);\n  this._generator = generator;\n  this._source = null;\n  this._inLoop = false;\n  this._iteration = 0;\n  this._$handleAny = function (event) {\n    return _this._handleAny(event);\n  };\n}\n\ninherit(S$33, Stream, {\n  _name: 'repeat',\n\n  _handleAny: function (event) {\n    if (event.type === END) {\n      this._source = null;\n      this._getSource();\n    } else {\n      this._emit(event.type, event.value);\n    }\n  },\n  _getSource: function () {\n    if (!this._inLoop) {\n      this._inLoop = true;\n      var generator = this._generator;\n      while (this._source === null && this._alive && this._active) {\n        this._source = generator(this._iteration++);\n        if (this._source) {\n          this._source.onAny(this._$handleAny);\n        } else {\n          this._emitEnd();\n        }\n      }\n      this._inLoop = false;\n    }\n  },\n  _onActivation: function () {\n    if (this._source) {\n      this._source.onAny(this._$handleAny);\n    } else {\n      this._getSource();\n    }\n  },\n  _onDeactivation: function () {\n    if (this._source) {\n      this._source.offAny(this._$handleAny);\n    }\n  },\n  _clear: function () {\n    Stream.prototype._clear.call(this);\n    this._generator = null;\n    this._source = null;\n    this._$handleAny = null;\n  }\n});\n\nvar repeat = function (generator) {\n  return new S$33(generator);\n};\n\nfunction concat$1(observables) {\n  return repeat(function (index) {\n    return observables.length > index ? observables[index] : false;\n  }).setName('concat');\n}\n\nfunction Pool() {\n  AbstractPool.call(this);\n}\n\ninherit(Pool, AbstractPool, {\n  _name: 'pool',\n\n  plug: function (obs) {\n    this._add(obs);\n    return this;\n  },\n  unplug: function (obs) {\n    this._remove(obs);\n    return this;\n  }\n});\n\nfunction FlatMap(source, fn, options) {\n  var _this = this;\n\n  AbstractPool.call(this, options);\n  this._source = source;\n  this._fn = fn;\n  this._mainEnded = false;\n  this._lastCurrent = null;\n  this._$handleMain = function (event) {\n    return _this._handleMain(event);\n  };\n}\n\ninherit(FlatMap, AbstractPool, {\n  _onActivation: function () {\n    AbstractPool.prototype._onActivation.call(this);\n    if (this._active) {\n      this._source.onAny(this._$handleMain);\n    }\n  },\n  _onDeactivation: function () {\n    AbstractPool.prototype._onDeactivation.call(this);\n    this._source.offAny(this._$handleMain);\n    this._hadNoEvSinceDeact = true;\n  },\n  _handleMain: function (event) {\n    if (event.type === VALUE) {\n      // Is latest value before deactivation survived, and now is 'current' on this activation?\n      // We don't want to handle such values, to prevent to constantly add\n      // same observale on each activation/deactivation when our main source\n      // is a `Kefir.conatant()` for example.\n      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n      if (!sameCurr) {\n        this._add(event.value, this._fn);\n      }\n      this._lastCurrent = event.value;\n      this._hadNoEvSinceDeact = false;\n    }\n\n    if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n\n    if (event.type === END) {\n      if (this._isEmpty()) {\n        this._emitEnd();\n      } else {\n        this._mainEnded = true;\n      }\n    }\n  },\n  _onEmpty: function () {\n    if (this._mainEnded) {\n      this._emitEnd();\n    }\n  },\n  _clear: function () {\n    AbstractPool.prototype._clear.call(this);\n    this._source = null;\n    this._lastCurrent = null;\n    this._$handleMain = null;\n  }\n});\n\nfunction FlatMapErrors(source, fn) {\n  FlatMap.call(this, source, fn);\n}\n\ninherit(FlatMapErrors, FlatMap, {\n  // Same as in FlatMap, only VALUE/ERROR flipped\n  _handleMain: function (event) {\n    if (event.type === ERROR) {\n      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n      if (!sameCurr) {\n        this._add(event.value, this._fn);\n      }\n      this._lastCurrent = event.value;\n      this._hadNoEvSinceDeact = false;\n    }\n\n    if (event.type === VALUE) {\n      this._emitValue(event.value);\n    }\n\n    if (event.type === END) {\n      if (this._isEmpty()) {\n        this._emitEnd();\n      } else {\n        this._mainEnded = true;\n      }\n    }\n  }\n});\n\nfunction createConstructor$1(BaseClass, name) {\n  return function AnonymousObservable(primary, secondary, options) {\n    var _this = this;\n\n    BaseClass.call(this);\n    this._primary = primary;\n    this._secondary = secondary;\n    this._name = primary._name + '.' + name;\n    this._lastSecondary = NOTHING;\n    this._$handleSecondaryAny = function (event) {\n      return _this._handleSecondaryAny(event);\n    };\n    this._$handlePrimaryAny = function (event) {\n      return _this._handlePrimaryAny(event);\n    };\n    this._init(options);\n  };\n}\n\nfunction createClassMethods$1(BaseClass) {\n  return {\n    _init: function () {},\n    _free: function () {},\n    _handlePrimaryValue: function (x) {\n      this._emitValue(x);\n    },\n    _handlePrimaryError: function (x) {\n      this._emitError(x);\n    },\n    _handlePrimaryEnd: function () {\n      this._emitEnd();\n    },\n    _handleSecondaryValue: function (x) {\n      this._lastSecondary = x;\n    },\n    _handleSecondaryError: function (x) {\n      this._emitError(x);\n    },\n    _handleSecondaryEnd: function () {},\n    _handlePrimaryAny: function (event) {\n      switch (event.type) {\n        case VALUE:\n          return this._handlePrimaryValue(event.value);\n        case ERROR:\n          return this._handlePrimaryError(event.value);\n        case END:\n          return this._handlePrimaryEnd(event.value);\n      }\n    },\n    _handleSecondaryAny: function (event) {\n      switch (event.type) {\n        case VALUE:\n          return this._handleSecondaryValue(event.value);\n        case ERROR:\n          return this._handleSecondaryError(event.value);\n        case END:\n          this._handleSecondaryEnd(event.value);\n          this._removeSecondary();\n      }\n    },\n    _removeSecondary: function () {\n      if (this._secondary !== null) {\n        this._secondary.offAny(this._$handleSecondaryAny);\n        this._$handleSecondaryAny = null;\n        this._secondary = null;\n      }\n    },\n    _onActivation: function () {\n      if (this._secondary !== null) {\n        this._secondary.onAny(this._$handleSecondaryAny);\n      }\n      if (this._active) {\n        this._primary.onAny(this._$handlePrimaryAny);\n      }\n    },\n    _onDeactivation: function () {\n      if (this._secondary !== null) {\n        this._secondary.offAny(this._$handleSecondaryAny);\n      }\n      this._primary.offAny(this._$handlePrimaryAny);\n    },\n    _clear: function () {\n      BaseClass.prototype._clear.call(this);\n      this._primary = null;\n      this._secondary = null;\n      this._lastSecondary = null;\n      this._$handleSecondaryAny = null;\n      this._$handlePrimaryAny = null;\n      this._free();\n    }\n  };\n}\n\nfunction createStream$1(name, mixin) {\n  var S = createConstructor$1(Stream, name);\n  inherit(S, Stream, createClassMethods$1(Stream), mixin);\n  return S;\n}\n\nfunction createProperty$1(name, mixin) {\n  var P = createConstructor$1(Property, name);\n  inherit(P, Property, createClassMethods$1(Property), mixin);\n  return P;\n}\n\nvar mixin$26 = {\n  _handlePrimaryValue: function (x) {\n    if (this._lastSecondary !== NOTHING && this._lastSecondary) {\n      this._emitValue(x);\n    }\n  },\n  _handleSecondaryEnd: function () {\n    if (this._lastSecondary === NOTHING || !this._lastSecondary) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$34 = createStream$1('filterBy', mixin$26);\nvar P$29 = createProperty$1('filterBy', mixin$26);\n\nfunction filterBy(primary, secondary) {\n  return new (primary._ofSameType(S$34, P$29))(primary, secondary);\n}\n\nvar id2 = function (_, x) {\n  return x;\n};\n\nfunction sampledBy(passive, active, combinator) {\n  var _combinator = combinator ? function (a, b) {\n    return combinator(b, a);\n  } : id2;\n  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');\n}\n\nvar mixin$27 = {\n  _handlePrimaryValue: function (x) {\n    if (this._lastSecondary !== NOTHING) {\n      this._emitValue(x);\n    }\n  },\n  _handleSecondaryEnd: function () {\n    if (this._lastSecondary === NOTHING) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$35 = createStream$1('skipUntilBy', mixin$27);\nvar P$30 = createProperty$1('skipUntilBy', mixin$27);\n\nfunction skipUntilBy(primary, secondary) {\n  return new (primary._ofSameType(S$35, P$30))(primary, secondary);\n}\n\nvar mixin$28 = {\n  _handleSecondaryValue: function () {\n    this._emitEnd();\n  }\n};\n\nvar S$36 = createStream$1('takeUntilBy', mixin$28);\nvar P$31 = createProperty$1('takeUntilBy', mixin$28);\n\nfunction takeUntilBy(primary, secondary) {\n  return new (primary._ofSameType(S$36, P$31))(primary, secondary);\n}\n\nvar mixin$29 = {\n  _init: function () {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$flushOnEnd = _ref.flushOnEnd,\n        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n\n    this._buff = [];\n    this._flushOnEnd = flushOnEnd;\n  },\n  _free: function () {\n    this._buff = null;\n  },\n  _flush: function () {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n  _handlePrimaryEnd: function () {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n  _onActivation: function () {\n    this._primary.onAny(this._$handlePrimaryAny);\n    if (this._alive && this._secondary !== null) {\n      this._secondary.onAny(this._$handleSecondaryAny);\n    }\n  },\n  _handlePrimaryValue: function (x) {\n    this._buff.push(x);\n  },\n  _handleSecondaryValue: function () {\n    this._flush();\n  },\n  _handleSecondaryEnd: function () {\n    if (!this._flushOnEnd) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$37 = createStream$1('bufferBy', mixin$29);\nvar P$32 = createProperty$1('bufferBy', mixin$29);\n\nfunction bufferBy(primary, secondary, options /* optional */) {\n  return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);\n}\n\nvar mixin$30 = {\n  _init: function () {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$flushOnEnd = _ref.flushOnEnd,\n        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd,\n        _ref$flushOnChange = _ref.flushOnChange,\n        flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;\n\n    this._buff = [];\n    this._flushOnEnd = flushOnEnd;\n    this._flushOnChange = flushOnChange;\n  },\n  _free: function () {\n    this._buff = null;\n  },\n  _flush: function () {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n  _handlePrimaryEnd: function () {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n  _handlePrimaryValue: function (x) {\n    this._buff.push(x);\n    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {\n      this._flush();\n    }\n  },\n  _handleSecondaryEnd: function () {\n    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {\n      this._emitEnd();\n    }\n  },\n  _handleSecondaryValue: function (x) {\n    if (this._flushOnChange && !x) {\n      this._flush();\n    }\n\n    // from default _handleSecondaryValue\n    this._lastSecondary = x;\n  }\n};\n\nvar S$38 = createStream$1('bufferWhileBy', mixin$30);\nvar P$33 = createProperty$1('bufferWhileBy', mixin$30);\n\nfunction bufferWhileBy(primary, secondary, options /* optional */) {\n  return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);\n}\n\nvar f = function () {\n  return false;\n};\nvar t = function () {\n  return true;\n};\n\nfunction awaiting(a, b) {\n  var result = merge([map$1(a, t), map$1(b, f)]);\n  result = skipDuplicates(result);\n  result = toProperty(result, f);\n  return result.setName(a, 'awaiting');\n}\n\nvar mixin$31 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    var result = fn(x);\n    if (result.convert) {\n      this._emitError(result.error);\n    } else {\n      this._emitValue(x);\n    }\n  }\n};\n\nvar S$39 = createStream('valuesToErrors', mixin$31);\nvar P$34 = createProperty('valuesToErrors', mixin$31);\n\nvar defFn = function (x) {\n  return { convert: true, error: x };\n};\n\nfunction valuesToErrors(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;\n\n  return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });\n}\n\nvar mixin$32 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleError: function (x) {\n    var fn = this._fn;\n    var result = fn(x);\n    if (result.convert) {\n      this._emitValue(result.value);\n    } else {\n      this._emitError(x);\n    }\n  }\n};\n\nvar S$40 = createStream('errorsToValues', mixin$32);\nvar P$35 = createProperty('errorsToValues', mixin$32);\n\nvar defFn$1 = function (x) {\n  return { convert: true, value: x };\n};\n\nfunction errorsToValues(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;\n\n  return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });\n}\n\nvar mixin$33 = {\n  _handleError: function (x) {\n    this._emitError(x);\n    this._emitEnd();\n  }\n};\n\nvar S$41 = createStream('endOnError', mixin$33);\nvar P$36 = createProperty('endOnError', mixin$33);\n\nfunction endOnError(obs) {\n  return new (obs._ofSameType(S$41, P$36))(obs);\n}\n\n// Create a stream\n// -----------------------------------------------------------------------------\n\n// () -> Stream\n// (number, any) -> Stream\n// (number, any) -> Stream\n// (number, Array<any>) -> Stream\n// (number, Function) -> Stream\n// (number, Function) -> Stream\n// (Function) -> Stream\n// (Function) -> Stream\n// Target = {addEventListener, removeEventListener}|{addListener, removeListener}|{on, off}\n// (Target, string, Function|undefined) -> Stream\n// (Function) -> Stream\n// Create a property\n// -----------------------------------------------------------------------------\n\n// (any) -> Property\n// (any) -> Property\n// Convert observables\n// -----------------------------------------------------------------------------\n\n// (Stream|Property, Function|undefined) -> Property\nObservable.prototype.toProperty = function (fn) {\n  return toProperty(this, fn);\n};\n\n// (Stream|Property) -> Stream\nObservable.prototype.changes = function () {\n  return changes(this);\n};\n\n// Interoperation with other implimentations\n// -----------------------------------------------------------------------------\n\n// (Promise) -> Property\n// (Stream|Property, Function|undefined) -> Promise\nObservable.prototype.toPromise = function (Promise) {\n  return toPromise(this, Promise);\n};\n\n// (ESObservable) -> Stream\n// (Stream|Property) -> ES7 Observable\nObservable.prototype.toESObservable = toESObservable;\nObservable.prototype[$$observable] = toESObservable;\n\n// Modify an observable\n// -----------------------------------------------------------------------------\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.map = function (fn) {\n  return map$1(this, fn);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.filter = function (fn) {\n  return filter(this, fn);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nObservable.prototype.take = function (n) {\n  return take(this, n);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nObservable.prototype.takeErrors = function (n) {\n  return takeErrors(this, n);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.takeWhile = function (fn) {\n  return takeWhile(this, fn);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nObservable.prototype.last = function () {\n  return last(this);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nObservable.prototype.skip = function (n) {\n  return skip(this, n);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.skipWhile = function (fn) {\n  return skipWhile(this, fn);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.skipDuplicates = function (fn) {\n  return skipDuplicates(this, fn);\n};\n\n// (Stream, Function|falsey, any|undefined) -> Stream\n// (Property, Function|falsey, any|undefined) -> Property\nObservable.prototype.diff = function (fn, seed) {\n  return diff(this, fn, seed);\n};\n\n// (Stream|Property, Function, any|undefined) -> Property\nObservable.prototype.scan = function (fn, seed) {\n  return scan(this, fn, seed);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.flatten = function (fn) {\n  return flatten(this, fn);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nObservable.prototype.delay = function (wait) {\n  return delay(this, wait);\n};\n\n// Options = {leading: boolean|undefined, trailing: boolean|undefined}\n// (Stream, number, Options|undefined) -> Stream\n// (Property, number, Options|undefined) -> Property\nObservable.prototype.throttle = function (wait, options) {\n  return throttle(this, wait, options);\n};\n\n// Options = {immediate: boolean|undefined}\n// (Stream, number, Options|undefined) -> Stream\n// (Property, number, Options|undefined) -> Property\nObservable.prototype.debounce = function (wait, options) {\n  return debounce(this, wait, options);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.mapErrors = function (fn) {\n  return mapErrors(this, fn);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.filterErrors = function (fn) {\n  return filterErrors(this, fn);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nObservable.prototype.ignoreValues = function () {\n  return ignoreValues(this);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nObservable.prototype.ignoreErrors = function () {\n  return ignoreErrors(this);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nObservable.prototype.ignoreEnd = function () {\n  return ignoreEnd(this);\n};\n\n// (Stream, Function) -> Stream\n// (Property, Function) -> Property\nObservable.prototype.beforeEnd = function (fn) {\n  return beforeEnd(this, fn);\n};\n\n// (Stream, number, number|undefined) -> Stream\n// (Property, number, number|undefined) -> Property\nObservable.prototype.slidingWindow = function (max, min) {\n  return slidingWindow(this, max, min);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, Function|falsey, Options|undefined) -> Stream\n// (Property, Function|falsey, Options|undefined) -> Property\nObservable.prototype.bufferWhile = function (fn, options) {\n  return bufferWhile(this, fn, options);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nObservable.prototype.bufferWithCount = function (count, options) {\n  return bufferWhile$1(this, count, options);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, number, number, Options|undefined) -> Stream\n// (Property, number, number, Options|undefined) -> Property\nObservable.prototype.bufferWithTimeOrCount = function (wait, count, options) {\n  return bufferWithTimeOrCount(this, wait, count, options);\n};\n\n// (Stream, Function) -> Stream\n// (Property, Function) -> Property\nObservable.prototype.transduce = function (transducer) {\n  return transduce(this, transducer);\n};\n\n// (Stream, Function) -> Stream\n// (Property, Function) -> Property\nObservable.prototype.withHandler = function (fn) {\n  return withHandler(this, fn);\n};\n\n// (Stream, Stream -> a) -> a\n// (Property, Property -> a) -> a\nObservable.prototype.thru = function (fn) {\n  return fn(this);\n};\n\n// Combine observables\n// -----------------------------------------------------------------------------\n\n// (Array<Stream|Property>, Function|undefiend) -> Stream\n// (Array<Stream|Property>, Array<Stream|Property>, Function|undefiend) -> Stream\nObservable.prototype.combine = function (other, combinator) {\n  return combine([this, other], combinator);\n};\n\n// (Array<Stream|Property>, Function|undefiend) -> Stream\nObservable.prototype.zip = function (other, combinator) {\n  return zip([this, other], combinator);\n};\n\n// (Array<Stream|Property>) -> Stream\nObservable.prototype.merge = function (other) {\n  return merge([this, other]);\n};\n\n// (Array<Stream|Property>) -> Stream\nObservable.prototype.concat = function (other) {\n  return concat$1([this, other]);\n};\n\n// () -> Pool\nvar pool = function () {\n  return new Pool();\n};\n\n// (Function) -> Stream\n// Options = {concurLim: number|undefined, queueLim: number|undefined, drop: 'old'|'new'|undefiend}\n// (Stream|Property, Function|falsey, Options|undefined) -> Stream\nObservable.prototype.flatMap = function (fn) {\n  return new FlatMap(this, fn).setName(this, 'flatMap');\n};\nObservable.prototype.flatMapLatest = function (fn) {\n  return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');\n};\nObservable.prototype.flatMapFirst = function (fn) {\n  return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');\n};\nObservable.prototype.flatMapConcat = function (fn) {\n  return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');\n};\nObservable.prototype.flatMapConcurLimit = function (fn, limit) {\n  return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');\n};\n\n// (Stream|Property, Function|falsey) -> Stream\nObservable.prototype.flatMapErrors = function (fn) {\n  return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');\n};\n\n// Combine two observables\n// -----------------------------------------------------------------------------\n\n// (Stream, Stream|Property) -> Stream\n// (Property, Stream|Property) -> Property\nObservable.prototype.filterBy = function (other) {\n  return filterBy(this, other);\n};\n\n// (Stream, Stream|Property, Function|undefiend) -> Stream\n// (Property, Stream|Property, Function|undefiend) -> Property\nObservable.prototype.sampledBy = function (other, combinator) {\n  return sampledBy(this, other, combinator);\n};\n\n// (Stream, Stream|Property) -> Stream\n// (Property, Stream|Property) -> Property\nObservable.prototype.skipUntilBy = function (other) {\n  return skipUntilBy(this, other);\n};\n\n// (Stream, Stream|Property) -> Stream\n// (Property, Stream|Property) -> Property\nObservable.prototype.takeUntilBy = function (other) {\n  return takeUntilBy(this, other);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, Stream|Property, Options|undefined) -> Stream\n// (Property, Stream|Property, Options|undefined) -> Property\nObservable.prototype.bufferBy = function (other, options) {\n  return bufferBy(this, other, options);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, Stream|Property, Options|undefined) -> Stream\n// (Property, Stream|Property, Options|undefined) -> Property\nObservable.prototype.bufferWhileBy = function (other, options) {\n  return bufferWhileBy(this, other, options);\n};\n\n// Deprecated\n// -----------------------------------------------------------------------------\n\nvar DEPRECATION_WARNINGS = true;\nfunction dissableDeprecationWarnings() {\n  DEPRECATION_WARNINGS = false;\n}\n\nfunction warn(msg) {\n  if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {\n    var msg2 = '\\nHere is an Error object for you containing the call stack:';\n    console.warn(msg, msg2, new Error());\n  }\n}\n\n// (Stream|Property, Stream|Property) -> Property\nObservable.prototype.awaiting = function (other) {\n  warn('You are using deprecated .awaiting() method, see https://github.com/kefirjs/kefir/issues/145');\n  return awaiting(this, other);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.valuesToErrors = function (fn) {\n  warn('You are using deprecated .valuesToErrors() method, see https://github.com/kefirjs/kefir/issues/149');\n  return valuesToErrors(this, fn);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.errorsToValues = function (fn) {\n  warn('You are using deprecated .errorsToValues() method, see https://github.com/kefirjs/kefir/issues/149');\n  return errorsToValues(this, fn);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nObservable.prototype.endOnError = function () {\n  warn('You are using deprecated .endOnError() method, see https://github.com/kefirjs/kefir/issues/150');\n  return endOnError(this);\n};\n\n// Exports\n// --------------------------------------------------------------------------\n\nvar Kefir = {\n  Observable: Observable,\n  Stream: Stream,\n  Property: Property,\n  never: never,\n  later: later,\n  interval: interval,\n  sequentially: sequentially,\n  fromPoll: fromPoll,\n  withInterval: withInterval,\n  fromCallback: fromCallback,\n  fromNodeCallback: fromNodeCallback,\n  fromEvents: fromEvents,\n  stream: stream,\n  constant: constant,\n  constantError: constantError,\n  fromPromise: fromPromise,\n  fromESObservable: fromESObservable,\n  combine: combine,\n  zip: zip,\n  merge: merge,\n  concat: concat$1,\n  Pool: Pool,\n  pool: pool,\n  repeat: repeat,\n  staticLand: staticLand\n};\n\nKefir.Kefir = Kefir;\n\n/* unused harmony default export */ var _unused_webpack_default_export = (Kefir);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(8)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2VmaXIvZGlzdC9rZWZpci5lc20uanM/MWMzMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7O0FBRUEsaURBQWlELG1DQUFtQztBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaURBQWlELFNBQVM7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQsU0FBUztBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlEQUFp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QUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwrQ0FBK0Msb0NBQW9DO0FBQ25GO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwrQ0FBK0Msb0JBQW9CO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxTQUFTO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxTQUFTO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNDQUFzQyxFQUFFLDRCQUE0QixFQUFFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQSxnQ0FBZ0MsNkJBQTZCO0FBQzdEO0FBQ0E7QUFDQSxnQ0FBZ0MsaUNBQWlDO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUU4VSwrRUFBSyxFQUFDIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgS2VmaXIuanMgdjMuOC42XG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL2tlZmlyanMva2VmaXJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVPYmoocHJvdG8pIHtcbiAgdmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGKCk7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQgLyosIG1peGluMSwgbWl4aW4yLi4uKi8pIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICBpID0gdm9pZCAwLFxuICAgICAgcHJvcCA9IHZvaWQgMDtcbiAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChwcm9wIGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgdGFyZ2V0W3Byb3BdID0gYXJndW1lbnRzW2ldW3Byb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpbmhlcml0KENoaWxkLCBQYXJlbnQgLyosIG1peGluMSwgbWl4aW4yLi4uKi8pIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICBpID0gdm9pZCAwO1xuICBDaGlsZC5wcm90b3R5cGUgPSBjcmVhdGVPYmooUGFyZW50LnByb3RvdHlwZSk7XG4gIENoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENoaWxkO1xuICBmb3IgKGkgPSAyOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBleHRlbmQoQ2hpbGQucHJvdG90eXBlLCBhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiBDaGlsZDtcbn1cblxudmFyIE5PVEhJTkcgPSBbJzxub3RoaW5nPiddO1xudmFyIEVORCA9ICdlbmQnO1xudmFyIFZBTFVFID0gJ3ZhbHVlJztcbnZhciBFUlJPUiA9ICdlcnJvcic7XG52YXIgQU5ZID0gJ2FueSc7XG5cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gIHZhciByZXN1bHQgPSB2b2lkIDAsXG4gICAgICBsZW5ndGggPSB2b2lkIDAsXG4gICAgICBpID0gdm9pZCAwLFxuICAgICAgaiA9IHZvaWQgMDtcbiAgaWYgKGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgaWYgKGIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgaiA9IDA7XG4gIHJlc3VsdCA9IG5ldyBBcnJheShhLmxlbmd0aCArIGIubGVuZ3RoKTtcbiAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKywgaisrKSB7XG4gICAgcmVzdWx0W2pdID0gYVtpXTtcbiAgfVxuICBsZW5ndGggPSBiLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrLCBqKyspIHtcbiAgICByZXN1bHRbal0gPSBiW2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmQoYXJyLCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aCxcbiAgICAgIGkgPSB2b2lkIDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBmaW5kQnlQcmVkKGFyciwgcHJlZCkge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aCxcbiAgICAgIGkgPSB2b2lkIDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChwcmVkKGFycltpXSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGNsb25lQXJyYXkoaW5wdXQpIHtcbiAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpLFxuICAgICAgaSA9IHZvaWQgMDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gaW5wdXRbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGlucHV0LCBpbmRleCkge1xuICB2YXIgbGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gdm9pZCAwLFxuICAgICAgaSA9IHZvaWQgMCxcbiAgICAgIGogPSB2b2lkIDA7XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9PSBpbmRleCkge1xuICAgICAgICAgIHJlc3VsdFtqXSA9IGlucHV0W2ldO1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcChpbnB1dCwgZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpLFxuICAgICAgaSA9IHZvaWQgMDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gZm4oaW5wdXRbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goYXJyLCBmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aCxcbiAgICAgIGkgPSB2b2lkIDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGZuKGFycltpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsbEFycmF5KGFyciwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGgsXG4gICAgICBpID0gdm9pZCAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBhcnJbaV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb250YWlucyhhcnIsIHZhbHVlKSB7XG4gIHJldHVybiBmaW5kKGFyciwgdmFsdWUpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gc2xpZGUoY3VyLCBuZXh0LCBtYXgpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKG1heCwgY3VyLmxlbmd0aCArIDEpLFxuICAgICAgb2Zmc2V0ID0gY3VyLmxlbmd0aCAtIGxlbmd0aCArIDEsXG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKSxcbiAgICAgIGkgPSB2b2lkIDA7XG4gIGZvciAoaSA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2kgLSBvZmZzZXRdID0gY3VyW2ldO1xuICB9XG4gIHJlc3VsdFtsZW5ndGggLSAxXSA9IG5leHQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGxTdWJzY3JpYmVyKHR5cGUsIGZuLCBldmVudCkge1xuICBpZiAodHlwZSA9PT0gQU5ZKSB7XG4gICAgZm4oZXZlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IGV2ZW50LnR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gVkFMVUUgfHwgdHlwZSA9PT0gRVJST1IpIHtcbiAgICAgIGZuKGV2ZW50LnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4oKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gRGlzcGF0Y2hlcigpIHtcbiAgdGhpcy5faXRlbXMgPSBbXTtcbiAgdGhpcy5fc3BpZXMgPSBbXTtcbiAgdGhpcy5faW5Mb29wID0gMDtcbiAgdGhpcy5fcmVtb3ZlZEl0ZW1zID0gbnVsbDtcbn1cblxuZXh0ZW5kKERpc3BhdGNoZXIucHJvdG90eXBlLCB7XG4gIGFkZDogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgdGhpcy5faXRlbXMgPSBjb25jYXQodGhpcy5faXRlbXMsIFt7IHR5cGU6IHR5cGUsIGZuOiBmbiB9XSk7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICB2YXIgaW5kZXggPSBmaW5kQnlQcmVkKHRoaXMuX2l0ZW1zLCBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgudHlwZSA9PT0gdHlwZSAmJiB4LmZuID09PSBmbjtcbiAgICB9KTtcblxuICAgIC8vIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiBhIG5vdGlmaWNhdGlvbiBsb29wLFxuICAgIC8vIHJlbWVtYmVyIHRoaXMgc3Vic2NyaWJlciB3YXMgcmVtb3ZlZFxuICAgIGlmICh0aGlzLl9pbkxvb3AgIT09IDAgJiYgaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAodGhpcy5fcmVtb3ZlZEl0ZW1zID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZWRJdGVtcyA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVtb3ZlZEl0ZW1zLnB1c2godGhpcy5faXRlbXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pdGVtcyA9IHJlbW92ZSh0aGlzLl9pdGVtcywgaW5kZXgpO1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gIH0sXG4gIGFkZFNweTogZnVuY3Rpb24gKGZuKSB7XG4gICAgdGhpcy5fc3BpZXMgPSBjb25jYXQodGhpcy5fc3BpZXMsIFtmbl0pO1xuICAgIHJldHVybiB0aGlzLl9zcGllcy5sZW5ndGg7XG4gIH0sXG5cblxuICAvLyBCZWNhdXNlIHNwaWVzIGFyZSBvbmx5IGV2ZXIgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm0gbG9nZ2luZyBhc1xuICAvLyB0aGVpciBvbmx5IHNpZGUgZWZmZWN0LCB3ZSBkb24ndCBuZWVkIHRoZSBzYW1lIGNvbXBsaWNhdGVkXG4gIC8vIHJlbW92YWwgbG9naWMgbGlrZSBpbiByZW1vdmUoKVxuICByZW1vdmVTcHk6IGZ1bmN0aW9uIChmbikge1xuICAgIHRoaXMuX3NwaWVzID0gcmVtb3ZlKHRoaXMuX3NwaWVzLCB0aGlzLl9zcGllcy5pbmRleE9mKGZuKSk7XG4gICAgcmV0dXJuIHRoaXMuX3NwaWVzLmxlbmd0aDtcbiAgfSxcbiAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX2luTG9vcCsrO1xuICAgIGZvciAodmFyIGkgPSAwLCBzcGllcyA9IHRoaXMuX3NwaWVzOyB0aGlzLl9zcGllcyAhPT0gbnVsbCAmJiBpIDwgc3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNwaWVzW2ldKGV2ZW50KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDAsIGl0ZW1zID0gdGhpcy5faXRlbXM7IF9pIDwgaXRlbXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAvLyBjbGVhbnVwIHdhcyBjYWxsZWRcbiAgICAgIGlmICh0aGlzLl9pdGVtcyA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gdGhpcyBzdWJzY3JpYmVyIHdhcyByZW1vdmVkXG4gICAgICBpZiAodGhpcy5fcmVtb3ZlZEl0ZW1zICE9PSBudWxsICYmIGNvbnRhaW5zKHRoaXMuX3JlbW92ZWRJdGVtcywgaXRlbXNbX2ldKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY2FsbFN1YnNjcmliZXIoaXRlbXNbX2ldLnR5cGUsIGl0ZW1zW19pXS5mbiwgZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLl9pbkxvb3AtLTtcbiAgICBpZiAodGhpcy5faW5Mb29wID09PSAwKSB7XG4gICAgICB0aGlzLl9yZW1vdmVkSXRlbXMgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9zcGllcyA9IG51bGw7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBPYnNlcnZhYmxlKCkge1xuICB0aGlzLl9kaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIoKTtcbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gIHRoaXMuX2FsaXZlID0gdHJ1ZTtcbiAgdGhpcy5fYWN0aXZhdGluZyA9IGZhbHNlO1xuICB0aGlzLl9sb2dIYW5kbGVycyA9IG51bGw7XG4gIHRoaXMuX3NweUhhbmRsZXJzID0gbnVsbDtcbn1cblxuZXh0ZW5kKE9ic2VydmFibGUucHJvdG90eXBlLCB7XG4gIF9uYW1lOiAnb2JzZXJ2YWJsZScsXG5cbiAgX29uQWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge30sXG4gIF9vbkRlYWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge30sXG4gIF9zZXRBY3RpdmU6IGZ1bmN0aW9uIChhY3RpdmUpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlICE9PSBhY3RpdmUpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX29uQWN0aXZhdGlvbigpO1xuICAgICAgICB0aGlzLl9hY3RpdmF0aW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkRlYWN0aXZhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fc2V0QWN0aXZlKGZhbHNlKTtcbiAgICB0aGlzLl9kaXNwYXRjaGVyLmNsZWFudXAoKTtcbiAgICB0aGlzLl9kaXNwYXRjaGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2dIYW5kbGVycyA9IG51bGw7XG4gIH0sXG4gIF9lbWl0OiBmdW5jdGlvbiAodHlwZSwgeCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBWQUxVRTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXRWYWx1ZSh4KTtcbiAgICAgIGNhc2UgRVJST1I6XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IoeCk7XG4gICAgICBjYXNlIEVORDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXRFbmQoKTtcbiAgICB9XG4gIH0sXG4gIF9lbWl0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9hbGl2ZSkge1xuICAgICAgdGhpcy5fZGlzcGF0Y2hlci5kaXNwYXRjaCh7IHR5cGU6IFZBTFVFLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgfVxuICB9LFxuICBfZW1pdEVycm9yOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fYWxpdmUpIHtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoZXIuZGlzcGF0Y2goeyB0eXBlOiBFUlJPUiwgdmFsdWU6IHZhbHVlIH0pO1xuICAgIH1cbiAgfSxcbiAgX2VtaXRFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fYWxpdmUpIHtcbiAgICAgIHRoaXMuX2FsaXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9kaXNwYXRjaGVyLmRpc3BhdGNoKHsgdHlwZTogRU5EIH0pO1xuICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICB9XG4gIH0sXG4gIF9vbjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgaWYgKHRoaXMuX2FsaXZlKSB7XG4gICAgICB0aGlzLl9kaXNwYXRjaGVyLmFkZCh0eXBlLCBmbik7XG4gICAgICB0aGlzLl9zZXRBY3RpdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxTdWJzY3JpYmVyKHR5cGUsIGZuLCB7IHR5cGU6IEVORCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgIGlmICh0aGlzLl9hbGl2ZSkge1xuICAgICAgdmFyIGNvdW50ID0gdGhpcy5fZGlzcGF0Y2hlci5yZW1vdmUodHlwZSwgZm4pO1xuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3NldEFjdGl2ZShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvblZhbHVlOiBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fb24oVkFMVUUsIGZuKTtcbiAgfSxcbiAgb25FcnJvcjogZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uKEVSUk9SLCBmbik7XG4gIH0sXG4gIG9uRW5kOiBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fb24oRU5ELCBmbik7XG4gIH0sXG4gIG9uQW55OiBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fb24oQU5ZLCBmbik7XG4gIH0sXG4gIG9mZlZhbHVlOiBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fb2ZmKFZBTFVFLCBmbik7XG4gIH0sXG4gIG9mZkVycm9yOiBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fb2ZmKEVSUk9SLCBmbik7XG4gIH0sXG4gIG9mZkVuZDogZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZihFTkQsIGZuKTtcbiAgfSxcbiAgb2ZmQW55OiBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fb2ZmKEFOWSwgZm4pO1xuICB9LFxuICBvYnNlcnZlOiBmdW5jdGlvbiAob2JzZXJ2ZXJPck9uVmFsdWUsIG9uRXJyb3IsIG9uRW5kKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgY2xvc2VkID0gZmFsc2U7XG5cbiAgICB2YXIgb2JzZXJ2ZXIgPSAhb2JzZXJ2ZXJPck9uVmFsdWUgfHwgdHlwZW9mIG9ic2VydmVyT3JPblZhbHVlID09PSAnZnVuY3Rpb24nID8geyB2YWx1ZTogb2JzZXJ2ZXJPck9uVmFsdWUsIGVycm9yOiBvbkVycm9yLCBlbmQ6IG9uRW5kIH0gOiBvYnNlcnZlck9yT25WYWx1ZTtcblxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gRU5EKSB7XG4gICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gVkFMVUUgJiYgb2JzZXJ2ZXIudmFsdWUpIHtcbiAgICAgICAgb2JzZXJ2ZXIudmFsdWUoZXZlbnQudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSBFUlJPUiAmJiBvYnNlcnZlci5lcnJvcikge1xuICAgICAgICBvYnNlcnZlci5lcnJvcihldmVudC52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IEVORCAmJiBvYnNlcnZlci5lbmQpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZW5kKGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbkFueShoYW5kbGVyKTtcblxuICAgIHJldHVybiB7XG4gICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgIF90aGlzLm9mZkFueShoYW5kbGVyKTtcbiAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gY2xvc2VkO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cblxuICAvLyBBIGFuZCBCIG11c3QgYmUgc3ViY2xhc3NlcyBvZiBTdHJlYW0gYW5kIFByb3BlcnR5IChvcmRlciBkb2Vzbid0IG1hdHRlcilcbiAgX29mU2FtZVR5cGU6IGZ1bmN0aW9uIChBLCBCKSB7XG4gICAgcmV0dXJuIEEucHJvdG90eXBlLmdldFR5cGUoKSA9PT0gdGhpcy5nZXRUeXBlKCkgPyBBIDogQjtcbiAgfSxcbiAgc2V0TmFtZTogZnVuY3Rpb24gKHNvdXJjZU9icyAvKiBvcHRpb25hbCAqLywgc2VsZk5hbWUpIHtcbiAgICB0aGlzLl9uYW1lID0gc2VsZk5hbWUgPyBzb3VyY2VPYnMuX25hbWUgKyAnLicgKyBzZWxmTmFtZSA6IHNvdXJjZU9icztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbG9nOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMudG9TdHJpbmcoKTtcblxuICAgIHZhciBpc0N1cnJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB0eXBlID0gJzwnICsgZXZlbnQudHlwZSArIChpc0N1cnJlbnQgPyAnOmN1cnJlbnQnIDogJycpICsgJz4nO1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEVORCkge1xuICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG5hbWUsIHR5cGUsIGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2FsaXZlKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvZ0hhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXJzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLl9sb2dIYW5kbGVycy5wdXNoKHsgbmFtZTogbmFtZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICB9XG5cbiAgICBpc0N1cnJlbnQgPSB0cnVlO1xuICAgIHRoaXMub25BbnkoaGFuZGxlcik7XG4gICAgaXNDdXJyZW50ID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb2ZmTG9nOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLl9sb2dIYW5kbGVycykge1xuICAgICAgdmFyIGhhbmRsZXJJbmRleCA9IGZpbmRCeVByZWQodGhpcy5fbG9nSGFuZGxlcnMsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai5uYW1lID09PSBuYW1lO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFuZGxlckluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLm9mZkFueSh0aGlzLl9sb2dIYW5kbGVyc1toYW5kbGVySW5kZXhdLmhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVycy5zcGxpY2UoaGFuZGxlckluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc3B5OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMudG9TdHJpbmcoKTtcblxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdHlwZSA9ICc8JyArIGV2ZW50LnR5cGUgKyAnPic7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gRU5EKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG5hbWUsIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2cobmFtZSwgdHlwZSwgZXZlbnQudmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2FsaXZlKSB7XG4gICAgICBpZiAoIXRoaXMuX3NweUhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMuX3NweUhhbmRsZXJzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLl9zcHlIYW5kbGVycy5wdXNoKHsgbmFtZTogbmFtZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoZXIuYWRkU3B5KGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb2ZmU3B5OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLl9zcHlIYW5kbGVycykge1xuICAgICAgdmFyIGhhbmRsZXJJbmRleCA9IGZpbmRCeVByZWQodGhpcy5fc3B5SGFuZGxlcnMsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai5uYW1lID09PSBuYW1lO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFuZGxlckluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaGVyLnJlbW92ZVNweSh0aGlzLl9zcHlIYW5kbGVyc1toYW5kbGVySW5kZXhdLmhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9zcHlIYW5kbGVycy5zcGxpY2UoaGFuZGxlckluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG4vLyBleHRlbmQoKSBjYW4ndCBoYW5kbGUgYHRvU3RyaW5nYCBpbiBJRThcbk9ic2VydmFibGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ1snICsgdGhpcy5fbmFtZSArICddJztcbn07XG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgT2JzZXJ2YWJsZS5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0KFN0cmVhbSwgT2JzZXJ2YWJsZSwge1xuICBfbmFtZTogJ3N0cmVhbScsXG5cbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnc3RyZWFtJztcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIFByb3BlcnR5KCkge1xuICBPYnNlcnZhYmxlLmNhbGwodGhpcyk7XG4gIHRoaXMuX2N1cnJlbnRFdmVudCA9IG51bGw7XG59XG5cbmluaGVyaXQoUHJvcGVydHksIE9ic2VydmFibGUsIHtcbiAgX25hbWU6ICdwcm9wZXJ0eScsXG5cbiAgX2VtaXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2FsaXZlKSB7XG4gICAgICB0aGlzLl9jdXJyZW50RXZlbnQgPSB7IHR5cGU6IFZBTFVFLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgIGlmICghdGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaGVyLmRpc3BhdGNoKHsgdHlwZTogVkFMVUUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9lbWl0RXJyb3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9hbGl2ZSkge1xuICAgICAgdGhpcy5fY3VycmVudEV2ZW50ID0geyB0eXBlOiBFUlJPUiwgdmFsdWU6IHZhbHVlIH07XG4gICAgICBpZiAoIXRoaXMuX2FjdGl2YXRpbmcpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hlci5kaXNwYXRjaCh7IHR5cGU6IEVSUk9SLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZW1pdEVuZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9hbGl2ZSkge1xuICAgICAgdGhpcy5fYWxpdmUgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaGVyLmRpc3BhdGNoKHsgdHlwZTogRU5EIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICB9XG4gIH0sXG4gIF9vbjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgaWYgKHRoaXMuX2FsaXZlKSB7XG4gICAgICB0aGlzLl9kaXNwYXRjaGVyLmFkZCh0eXBlLCBmbik7XG4gICAgICB0aGlzLl9zZXRBY3RpdmUodHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jdXJyZW50RXZlbnQgIT09IG51bGwpIHtcbiAgICAgIGNhbGxTdWJzY3JpYmVyKHR5cGUsIGZuLCB0aGlzLl9jdXJyZW50RXZlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2FsaXZlKSB7XG4gICAgICBjYWxsU3Vic2NyaWJlcih0eXBlLCBmbiwgeyB0eXBlOiBFTkQgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdwcm9wZXJ0eSc7XG4gIH1cbn0pO1xuXG52YXIgbmV2ZXJTID0gbmV3IFN0cmVhbSgpO1xubmV2ZXJTLl9lbWl0RW5kKCk7XG5uZXZlclMuX25hbWUgPSAnbmV2ZXInO1xuXG5mdW5jdGlvbiBuZXZlcigpIHtcbiAgcmV0dXJuIG5ldmVyUztcbn1cblxuZnVuY3Rpb24gdGltZUJhc2VkKG1peGluKSB7XG4gIGZ1bmN0aW9uIEFub255bW91c1N0cmVhbSh3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIFN0cmVhbS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3dhaXQgPSB3YWl0O1xuICAgIHRoaXMuX2ludGVydmFsSWQgPSBudWxsO1xuICAgIHRoaXMuXyRvblRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuX29uVGljaygpO1xuICAgIH07XG4gICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgfVxuXG4gIGluaGVyaXQoQW5vbnltb3VzU3RyZWFtLCBTdHJlYW0sIHtcbiAgICBfaW5pdDogZnVuY3Rpb24gKCkge30sXG4gICAgX2ZyZWU6IGZ1bmN0aW9uICgpIHt9LFxuICAgIF9vblRpY2s6IGZ1bmN0aW9uICgpIHt9LFxuICAgIF9vbkFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2ludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh0aGlzLl8kb25UaWNrLCB0aGlzLl93YWl0KTtcbiAgICB9LFxuICAgIF9vbkRlYWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2ludGVydmFsSWQgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbElkKTtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFN0cmVhbS5wcm90b3R5cGUuX2NsZWFyLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLl8kb25UaWNrID0gbnVsbDtcbiAgICAgIHRoaXMuX2ZyZWUoKTtcbiAgICB9XG4gIH0sIG1peGluKTtcblxuICByZXR1cm4gQW5vbnltb3VzU3RyZWFtO1xufVxuXG52YXIgUyA9IHRpbWVCYXNlZCh7XG4gIF9uYW1lOiAnbGF0ZXInLFxuXG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciB4ID0gX3JlZi54O1xuXG4gICAgdGhpcy5feCA9IHg7XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5feCA9IG51bGw7XG4gIH0sXG4gIF9vblRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9lbWl0VmFsdWUodGhpcy5feCk7XG4gICAgdGhpcy5fZW1pdEVuZCgpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbGF0ZXIod2FpdCwgeCkge1xuICByZXR1cm4gbmV3IFMod2FpdCwgeyB4OiB4IH0pO1xufVxuXG52YXIgUyQxID0gdGltZUJhc2VkKHtcbiAgX25hbWU6ICdpbnRlcnZhbCcsXG5cbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHggPSBfcmVmLng7XG5cbiAgICB0aGlzLl94ID0geDtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl94ID0gbnVsbDtcbiAgfSxcbiAgX29uVGljazogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2VtaXRWYWx1ZSh0aGlzLl94KTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGludGVydmFsKHdhaXQsIHgpIHtcbiAgcmV0dXJuIG5ldyBTJDEod2FpdCwgeyB4OiB4IH0pO1xufVxuXG52YXIgUyQyID0gdGltZUJhc2VkKHtcbiAgX25hbWU6ICdzZXF1ZW50aWFsbHknLFxuXG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciB4cyA9IF9yZWYueHM7XG5cbiAgICB0aGlzLl94cyA9IGNsb25lQXJyYXkoeHMpO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3hzID0gbnVsbDtcbiAgfSxcbiAgX29uVGljazogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl94cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh0aGlzLl94c1swXSk7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh0aGlzLl94cy5zaGlmdCgpKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBzZXF1ZW50aWFsbHkod2FpdCwgeHMpIHtcbiAgcmV0dXJuIHhzLmxlbmd0aCA9PT0gMCA/IG5ldmVyKCkgOiBuZXcgUyQyKHdhaXQsIHsgeHM6IHhzIH0pO1xufVxuXG52YXIgUyQzID0gdGltZUJhc2VkKHtcbiAgX25hbWU6ICdmcm9tUG9sbCcsXG5cbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGZuID0gX3JlZi5mbjtcblxuICAgIHRoaXMuX2ZuID0gZm47XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZm4gPSBudWxsO1xuICB9LFxuICBfb25UaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZuID0gdGhpcy5fZm47XG4gICAgdGhpcy5fZW1pdFZhbHVlKGZuKCkpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZnJvbVBvbGwod2FpdCwgZm4pIHtcbiAgcmV0dXJuIG5ldyBTJDMod2FpdCwgeyBmbjogZm4gfSk7XG59XG5cbmZ1bmN0aW9uIGVtaXR0ZXIob2JzKSB7XG4gIGZ1bmN0aW9uIHZhbHVlKHgpIHtcbiAgICBvYnMuX2VtaXRWYWx1ZSh4KTtcbiAgICByZXR1cm4gb2JzLl9hY3RpdmU7XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvcih4KSB7XG4gICAgb2JzLl9lbWl0RXJyb3IoeCk7XG4gICAgcmV0dXJuIG9icy5fYWN0aXZlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kKCkge1xuICAgIG9icy5fZW1pdEVuZCgpO1xuICAgIHJldHVybiBvYnMuX2FjdGl2ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV2ZW50KGUpIHtcbiAgICBvYnMuX2VtaXQoZS50eXBlLCBlLnZhbHVlKTtcbiAgICByZXR1cm4gb2JzLl9hY3RpdmU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBlcnJvcjogZXJyb3IsXG4gICAgZW5kOiBlbmQsXG4gICAgZXZlbnQ6IGV2ZW50LFxuXG4gICAgLy8gbGVnYWN5XG4gICAgZW1pdDogdmFsdWUsXG4gICAgZW1pdEV2ZW50OiBldmVudFxuICB9O1xufVxuXG52YXIgUyQ0ID0gdGltZUJhc2VkKHtcbiAgX25hbWU6ICd3aXRoSW50ZXJ2YWwnLFxuXG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBlbWl0dGVyKHRoaXMpO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgICB0aGlzLl9lbWl0dGVyID0gbnVsbDtcbiAgfSxcbiAgX29uVGljazogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIGZuKHRoaXMuX2VtaXR0ZXIpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gd2l0aEludGVydmFsKHdhaXQsIGZuKSB7XG4gIHJldHVybiBuZXcgUyQ0KHdhaXQsIHsgZm46IGZuIH0pO1xufVxuXG5mdW5jdGlvbiBTJDUoZm4pIHtcbiAgU3RyZWFtLmNhbGwodGhpcyk7XG4gIHRoaXMuX2ZuID0gZm47XG4gIHRoaXMuX3Vuc3Vic2NyaWJlID0gbnVsbDtcbn1cblxuaW5oZXJpdChTJDUsIFN0cmVhbSwge1xuICBfbmFtZTogJ3N0cmVhbScsXG5cbiAgX29uQWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIHZhciB1bnN1YnNjcmliZSA9IGZuKGVtaXR0ZXIodGhpcykpO1xuICAgIHRoaXMuX3Vuc3Vic2NyaWJlID0gdHlwZW9mIHVuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nID8gdW5zdWJzY3JpYmUgOiBudWxsO1xuXG4gICAgLy8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9rZWZpcmpzL2tlZmlyL2lzc3Vlcy8zNVxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9jYWxsVW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH0sXG4gIF9jYWxsVW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdW5zdWJzY3JpYmUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLl91bnN1YnNjcmliZSA9IG51bGw7XG4gICAgfVxuICB9LFxuICBfb25EZWFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYWxsVW5zdWJzY3JpYmUoKTtcbiAgfSxcbiAgX2NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgU3RyZWFtLnByb3RvdHlwZS5fY2xlYXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9mbiA9IG51bGw7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBzdHJlYW0oZm4pIHtcbiAgcmV0dXJuIG5ldyBTJDUoZm4pO1xufVxuXG5mdW5jdGlvbiBmcm9tQ2FsbGJhY2soY2FsbGJhY2tDb25zdW1lcikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgcmV0dXJuIHN0cmVhbShmdW5jdGlvbiAoZW1pdHRlcikge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsYmFja0NvbnN1bWVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGVtaXR0ZXIuZW1pdCh4KTtcbiAgICAgICAgZW1pdHRlci5lbmQoKTtcbiAgICAgIH0pO1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pLnNldE5hbWUoJ2Zyb21DYWxsYmFjaycpO1xufVxuXG5mdW5jdGlvbiBmcm9tTm9kZUNhbGxiYWNrKGNhbGxiYWNrQ29uc3VtZXIpIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gIHJldHVybiBzdHJlYW0oZnVuY3Rpb24gKGVtaXR0ZXIpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGJhY2tDb25zdW1lcihmdW5jdGlvbiAoZXJyb3IsIHgpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgZW1pdHRlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW1pdHRlci5lbWl0KHgpO1xuICAgICAgICB9XG4gICAgICAgIGVtaXR0ZXIuZW5kKCk7XG4gICAgICB9KTtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgfVxuICB9KS5zZXROYW1lKCdmcm9tTm9kZUNhbGxiYWNrJyk7XG59XG5cbmZ1bmN0aW9uIHNwcmVhZChmbiwgbGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9O1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gZm4oYVswXSk7XG4gICAgICB9O1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gZm4oYVswXSwgYVsxXSk7XG4gICAgICB9O1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gZm4oYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgICB9O1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gZm4oYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGEpO1xuICAgICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseShmbiwgYywgYSkge1xuICB2YXIgYUxlbmd0aCA9IGEgPyBhLmxlbmd0aCA6IDA7XG4gIGlmIChjID09IG51bGwpIHtcbiAgICBzd2l0Y2ggKGFMZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBmbihhWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGZuKGFbMF0sIGFbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gZm4oYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBmbihhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoIChhTGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmbi5jYWxsKGMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGMsIGEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmcm9tU3ViVW5zdWIoc3ViLCB1bnN1YiwgdHJhbnNmb3JtZXIgLyogRnVuY3Rpb24gfCBmYWxzZXkgKi8pIHtcbiAgcmV0dXJuIHN0cmVhbShmdW5jdGlvbiAoZW1pdHRlcikge1xuICAgIHZhciBoYW5kbGVyID0gdHJhbnNmb3JtZXIgPyBmdW5jdGlvbiAoKSB7XG4gICAgICBlbWl0dGVyLmVtaXQoYXBwbHkodHJhbnNmb3JtZXIsIHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH0gOiBmdW5jdGlvbiAoeCkge1xuICAgICAgZW1pdHRlci5lbWl0KHgpO1xuICAgIH07XG5cbiAgICBzdWIoaGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bnN1YihoYW5kbGVyKTtcbiAgICB9O1xuICB9KS5zZXROYW1lKCdmcm9tU3ViVW5zdWInKTtcbn1cblxudmFyIHBhaXJzID0gW1snYWRkRXZlbnRMaXN0ZW5lcicsICdyZW1vdmVFdmVudExpc3RlbmVyJ10sIFsnYWRkTGlzdGVuZXInLCAncmVtb3ZlTGlzdGVuZXInXSwgWydvbicsICdvZmYnXV07XG5cbmZ1bmN0aW9uIGZyb21FdmVudHModGFyZ2V0LCBldmVudE5hbWUsIHRyYW5zZm9ybWVyKSB7XG4gIHZhciBzdWIgPSB2b2lkIDAsXG4gICAgICB1bnN1YiA9IHZvaWQgMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRbcGFpcnNbaV1bMF1dID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0YXJnZXRbcGFpcnNbaV1bMV1dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdWIgPSBwYWlyc1tpXVswXTtcbiAgICAgIHVuc3ViID0gcGFpcnNbaV1bMV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3ViID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgZG9uJ3Qgc3VwcG9ydCBhbnkgb2YgXCIgKyAnYWRkRXZlbnRMaXN0ZW5lci9yZW1vdmVFdmVudExpc3RlbmVyLCBhZGRMaXN0ZW5lci9yZW1vdmVMaXN0ZW5lciwgb24vb2ZmIG1ldGhvZCBwYWlyJyk7XG4gIH1cblxuICByZXR1cm4gZnJvbVN1YlVuc3ViKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRhcmdldFtzdWJdKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gIH0sIGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRhcmdldFt1bnN1Yl0oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgfSwgdHJhbnNmb3JtZXIpLnNldE5hbWUoJ2Zyb21FdmVudHMnKTtcbn1cblxuLy8gSEFDSzpcbi8vICAgV2UgZG9uJ3QgY2FsbCBwYXJlbnQgQ2xhc3MgY29uc3RydWN0b3IsIGJ1dCBpbnN0ZWFkIHB1dHRpbmcgYWxsIG5lY2Vzc2FyeVxuLy8gICBwcm9wZXJ0aWVzIGludG8gcHJvdG90eXBlIHRvIHNpbXVsYXRlIGVuZGVkIFByb3BlcnR5XG4vLyAgIChzZWUgUHJvcHBlcnR5IGFuZCBPYnNlcnZhYmxlIGNsYXNzZXMpLlxuXG5mdW5jdGlvbiBQKHZhbHVlKSB7XG4gIHRoaXMuX2N1cnJlbnRFdmVudCA9IHsgdHlwZTogJ3ZhbHVlJywgdmFsdWU6IHZhbHVlLCBjdXJyZW50OiB0cnVlIH07XG59XG5cbmluaGVyaXQoUCwgUHJvcGVydHksIHtcbiAgX25hbWU6ICdjb25zdGFudCcsXG4gIF9hY3RpdmU6IGZhbHNlLFxuICBfYWN0aXZhdGluZzogZmFsc2UsXG4gIF9hbGl2ZTogZmFsc2UsXG4gIF9kaXNwYXRjaGVyOiBudWxsLFxuICBfbG9nSGFuZGxlcnM6IG51bGxcbn0pO1xuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBuZXcgUCh4KTtcbn1cblxuLy8gSEFDSzpcbi8vICAgV2UgZG9uJ3QgY2FsbCBwYXJlbnQgQ2xhc3MgY29uc3RydWN0b3IsIGJ1dCBpbnN0ZWFkIHB1dHRpbmcgYWxsIG5lY2Vzc2FyeVxuLy8gICBwcm9wZXJ0aWVzIGludG8gcHJvdG90eXBlIHRvIHNpbXVsYXRlIGVuZGVkIFByb3BlcnR5XG4vLyAgIChzZWUgUHJvcHBlcnR5IGFuZCBPYnNlcnZhYmxlIGNsYXNzZXMpLlxuXG5mdW5jdGlvbiBQJDEodmFsdWUpIHtcbiAgdGhpcy5fY3VycmVudEV2ZW50ID0geyB0eXBlOiAnZXJyb3InLCB2YWx1ZTogdmFsdWUsIGN1cnJlbnQ6IHRydWUgfTtcbn1cblxuaW5oZXJpdChQJDEsIFByb3BlcnR5LCB7XG4gIF9uYW1lOiAnY29uc3RhbnRFcnJvcicsXG4gIF9hY3RpdmU6IGZhbHNlLFxuICBfYWN0aXZhdGluZzogZmFsc2UsXG4gIF9hbGl2ZTogZmFsc2UsXG4gIF9kaXNwYXRjaGVyOiBudWxsLFxuICBfbG9nSGFuZGxlcnM6IG51bGxcbn0pO1xuXG5mdW5jdGlvbiBjb25zdGFudEVycm9yKHgpIHtcbiAgcmV0dXJuIG5ldyBQJDEoeCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnN0cnVjdG9yKEJhc2VDbGFzcywgbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gQW5vbnltb3VzT2JzZXJ2YWJsZShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgQmFzZUNsYXNzLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX25hbWUgPSBzb3VyY2UuX25hbWUgKyAnLicgKyBuYW1lO1xuICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgdGhpcy5fJGhhbmRsZUFueSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVBbnkoZXZlbnQpO1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzTWV0aG9kcyhCYXNlQ2xhc3MpIHtcbiAgcmV0dXJuIHtcbiAgICBfaW5pdDogZnVuY3Rpb24gKCkge30sXG4gICAgX2ZyZWU6IGZ1bmN0aW9uICgpIHt9LFxuICAgIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh4KTtcbiAgICB9LFxuICAgIF9oYW5kbGVFcnJvcjogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcih4KTtcbiAgICB9LFxuICAgIF9oYW5kbGVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICB9LFxuICAgIF9oYW5kbGVBbnk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgVkFMVUU6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVZhbHVlKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgY2FzZSBFUlJPUjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlRXJyb3IoZXZlbnQudmFsdWUpO1xuICAgICAgICBjYXNlIEVORDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlRW5kKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfb25BY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zb3VyY2Uub25BbnkodGhpcy5fJGhhbmRsZUFueSk7XG4gICAgfSxcbiAgICBfb25EZWFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3NvdXJjZS5vZmZBbnkodGhpcy5fJGhhbmRsZUFueSk7XG4gICAgfSxcbiAgICBfY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJhc2VDbGFzcy5wcm90b3R5cGUuX2NsZWFyLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5fJGhhbmRsZUFueSA9IG51bGw7XG4gICAgICB0aGlzLl9mcmVlKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW0obmFtZSwgbWl4aW4pIHtcbiAgdmFyIFMgPSBjcmVhdGVDb25zdHJ1Y3RvcihTdHJlYW0sIG5hbWUpO1xuICBpbmhlcml0KFMsIFN0cmVhbSwgY3JlYXRlQ2xhc3NNZXRob2RzKFN0cmVhbSksIG1peGluKTtcbiAgcmV0dXJuIFM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5KG5hbWUsIG1peGluKSB7XG4gIHZhciBQID0gY3JlYXRlQ29uc3RydWN0b3IoUHJvcGVydHksIG5hbWUpO1xuICBpbmhlcml0KFAsIFByb3BlcnR5LCBjcmVhdGVDbGFzc01ldGhvZHMoUHJvcGVydHkpLCBtaXhpbik7XG4gIHJldHVybiBQO1xufVxuXG52YXIgUCQyID0gY3JlYXRlUHJvcGVydHkoJ3RvUHJvcGVydHknLCB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9nZXRJbml0aWFsQ3VycmVudCA9IGZuO1xuICB9LFxuICBfb25BY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2dldEluaXRpYWxDdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZ2V0SW5pdGlhbCA9IHRoaXMuX2dldEluaXRpYWxDdXJyZW50O1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKGdldEluaXRpYWwoKSk7XG4gICAgfVxuICAgIHRoaXMuX3NvdXJjZS5vbkFueSh0aGlzLl8kaGFuZGxlQW55KTsgLy8gY29waWVkIGZyb20gcGF0dGVybnMvb25lLXNvdXJjZVxuICB9XG59KTtcblxuZnVuY3Rpb24gdG9Qcm9wZXJ0eShvYnMpIHtcbiAgdmFyIGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gIGlmIChmbiAhPT0gbnVsbCAmJiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBzaG91bGQgY2FsbCB0b1Byb3BlcnR5KCkgd2l0aCBhIGZ1bmN0aW9uIG9yIG5vIGFyZ3VtZW50cy4nKTtcbiAgfVxuICByZXR1cm4gbmV3IFAkMihvYnMsIHsgZm46IGZuIH0pO1xufVxuXG52YXIgUyQ2ID0gY3JlYXRlU3RyZWFtKCdjaGFuZ2VzJywge1xuICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmF0aW5nKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoeCk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlRXJyb3I6IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmF0aW5nKSB7XG4gICAgICB0aGlzLl9lbWl0RXJyb3IoeCk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gY2hhbmdlcyhvYnMpIHtcbiAgcmV0dXJuIG5ldyBTJDYob2JzKTtcbn1cblxuZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZSkge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgdmFyIHJlc3VsdCA9IHN0cmVhbShmdW5jdGlvbiAoZW1pdHRlcikge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICB2YXIgb25WYWx1ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGVtaXR0ZXIuZW1pdCh4KTtcbiAgICAgICAgZW1pdHRlci5lbmQoKTtcbiAgICAgIH07XG4gICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGVtaXR0ZXIuZXJyb3IoeCk7XG4gICAgICAgIGVtaXR0ZXIuZW5kKCk7XG4gICAgICB9O1xuICAgICAgdmFyIF9wcm9taXNlID0gcHJvbWlzZS50aGVuKG9uVmFsdWUsIG9uRXJyb3IpO1xuXG4gICAgICAvLyBwcmV2ZW50IGxpYnJhcmllcyBsaWtlICdRJyBvciAnd2hlbicgZnJvbSBzd2FsbG93aW5nIGV4Y2VwdGlvbnNcbiAgICAgIGlmIChfcHJvbWlzZSAmJiB0eXBlb2YgX3Byb21pc2UuZG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfcHJvbWlzZS5kb25lKCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdG9Qcm9wZXJ0eShyZXN1bHQsIG51bGwpLnNldE5hbWUoJ2Zyb21Qcm9taXNlJyk7XG59XG5cbmZ1bmN0aW9uIGdldEdsb2RhbFByb21pc2UoKSB7XG4gIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBQcm9taXNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzbid0IGRlZmF1bHQgUHJvbWlzZSwgdXNlIHNoaW0gb3IgcGFyYW1ldGVyXCIpO1xuICB9XG59XG5cbnZhciB0b1Byb21pc2UgPSBmdW5jdGlvbiAob2JzKSB7XG4gIHZhciBQcm9taXNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBnZXRHbG9kYWxQcm9taXNlKCk7XG5cbiAgdmFyIGxhc3QgPSBudWxsO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIG9icy5vbkFueShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50eXBlID09PSBFTkQgJiYgbGFzdCAhPT0gbnVsbCkge1xuICAgICAgICAobGFzdC50eXBlID09PSBWQUxVRSA/IHJlc29sdmUgOiByZWplY3QpKGxhc3QudmFsdWUpO1xuICAgICAgICBsYXN0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3QgPSBldmVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgcG9ueWZpbGwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGw7XG5mdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgX1N5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgX1N5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChfU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0X1N5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG59KTtcblxudmFyIGluZGV4JDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cblxuXG52YXIgX3BvbnlmaWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocG9ueWZpbGwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9O1xufVxuXG52YXIgcm9vdDsgLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgY29tbW9uanNHbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBjb21tb25qc0dsb2JhbDtcbn0gZWxzZSB7XG4gIHJvb3QgPSBtb2R1bGU7XG59XG5cbnZhciByZXN1bHQgPSAoMCwgX3BvbnlmaWxsMlsnZGVmYXVsdCddKShyb290KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJlc3VsdDtcbn0pO1xuXG52YXIgaW5kZXggPSBpbmRleCQxO1xuXG4vLyB0aGlzIGZpbGUgY29udGFpbnMgc29tZSBob3QgSlMgbW9kdWxlcyBzeXN0ZW1zIHN0dWZmXG5cbnZhciAkJG9ic2VydmFibGUgPSBpbmRleC5kZWZhdWx0ID8gaW5kZXguZGVmYXVsdCA6IGluZGV4O1xuXG5mdW5jdGlvbiBmcm9tRVNPYnNlcnZhYmxlKF9vYnNlcnZhYmxlKSB7XG4gIHZhciBvYnNlcnZhYmxlID0gX29ic2VydmFibGVbJCRvYnNlcnZhYmxlXSA/IF9vYnNlcnZhYmxlWyQkb2JzZXJ2YWJsZV0oKSA6IF9vYnNlcnZhYmxlO1xuICByZXR1cm4gc3RyZWFtKGZ1bmN0aW9uIChlbWl0dGVyKSB7XG4gICAgdmFyIHVuc3ViID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBlbWl0dGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgZW1pdHRlci5lbmQoKTtcbiAgICAgIH0sXG4gICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZW1pdHRlci5lbWl0KHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBlbWl0dGVyLmVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHVuc3ViLnVuc3Vic2NyaWJlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB1bnN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuc3ViO1xuICAgIH1cbiAgfSkuc2V0TmFtZSgnZnJvbUVTT2JzZXJ2YWJsZScpO1xufVxuXG5mdW5jdGlvbiBFU09ic2VydmFibGUob2JzZXJ2YWJsZSkge1xuICB0aGlzLl9vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZS50YWtlRXJyb3JzKDEpO1xufVxuXG5leHRlbmQoRVNPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChvYnNlcnZlck9yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvYnNlcnZlciA9IHR5cGVvZiBvYnNlcnZlck9yT25OZXh0ID09PSAnZnVuY3Rpb24nID8geyBuZXh0OiBvYnNlcnZlck9yT25OZXh0LCBlcnJvcjogb25FcnJvciwgY29tcGxldGU6IG9uQ29tcGxldGUgfSA6IG9ic2VydmVyT3JPbk5leHQ7XG5cbiAgICB2YXIgZm4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50eXBlID09PSBFTkQpIHtcbiAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFZBTFVFICYmIG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dChldmVudC52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IEVSUk9SICYmIG9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKGV2ZW50LnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gRU5EICYmIG9ic2VydmVyLmNvbXBsZXRlKSB7XG4gICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fb2JzZXJ2YWJsZS5vbkFueShmbik7XG4gICAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuXG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgIF90aGlzLl9vYnNlcnZhYmxlLm9mZkFueShmbik7XG4gICAgICB9LFxuICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbn0pO1xuXG4vLyBOZWVkIHRvIGFzc2lnbiBkaXJlY3RseSBiL2MgU3ltYm9scyBhcmVuJ3QgZW51bWVyYWJsZS5cbkVTT2JzZXJ2YWJsZS5wcm90b3R5cGVbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB0b0VTT2JzZXJ2YWJsZSgpIHtcbiAgcmV0dXJuIG5ldyBFU09ic2VydmFibGUodGhpcyk7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Qoc291cmNlLCBrZXlzLCB2YWx1ZXMpIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB2YWx1ZXMucHVzaChzb3VyY2VbcHJvcF0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JzQ29tYmluYXRvcihlcnJvcnMpIHtcbiAgdmFyIGxhdGVzdEVycm9yID0gdm9pZCAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlcnJvcnNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGxhdGVzdEVycm9yID09PSB1bmRlZmluZWQgfHwgbGF0ZXN0RXJyb3IuaW5kZXggPCBlcnJvcnNbaV0uaW5kZXgpIHtcbiAgICAgICAgbGF0ZXN0RXJyb3IgPSBlcnJvcnNbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsYXRlc3RFcnJvci5lcnJvcjtcbn1cblxuZnVuY3Rpb24gQ29tYmluZShhY3RpdmUsIHBhc3NpdmUsIGNvbWJpbmF0b3IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbiAgdGhpcy5fYWN0aXZlQ291bnQgPSBhY3RpdmUubGVuZ3RoO1xuICB0aGlzLl9zb3VyY2VzID0gY29uY2F0KGFjdGl2ZSwgcGFzc2l2ZSk7XG4gIHRoaXMuX2NvbWJpbmF0b3IgPSBjb21iaW5hdG9yO1xuICB0aGlzLl9hbGl2ZUNvdW50ID0gMDtcbiAgdGhpcy5fbGF0ZXN0VmFsdWVzID0gbmV3IEFycmF5KHRoaXMuX3NvdXJjZXMubGVuZ3RoKTtcbiAgdGhpcy5fbGF0ZXN0RXJyb3JzID0gbmV3IEFycmF5KHRoaXMuX3NvdXJjZXMubGVuZ3RoKTtcbiAgZmlsbEFycmF5KHRoaXMuX2xhdGVzdFZhbHVlcywgTk9USElORyk7XG4gIHRoaXMuX2VtaXRBZnRlckFjdGl2YXRpb24gPSBmYWxzZTtcbiAgdGhpcy5fZW5kQWZ0ZXJBY3RpdmF0aW9uID0gZmFsc2U7XG4gIHRoaXMuX2xhdGVzdEVycm9ySW5kZXggPSAwO1xuXG4gIHRoaXMuXyRoYW5kbGVycyA9IFtdO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgX3RoaXMuXyRoYW5kbGVycy5wdXNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVBbnkoaSwgZXZlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIF9sb29wKGkpO1xuICB9XG59XG5cbmluaGVyaXQoQ29tYmluZSwgU3RyZWFtLCB7XG4gIF9uYW1lOiAnY29tYmluZScsXG5cbiAgX29uQWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2FsaXZlQ291bnQgPSB0aGlzLl9hY3RpdmVDb3VudDtcblxuICAgIC8vIHdlIG5lZWQgdG8gc3VzY3JpYmUgdG8gX3Bhc3NpdmVfIHNvdXJjZXMgYmVmb3JlIF9hY3RpdmVfXG4gICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20va2VmaXJqcy9rZWZpci9pc3N1ZXMvOTgpXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX2FjdGl2ZUNvdW50OyBpIDwgdGhpcy5fc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fc291cmNlc1tpXS5vbkFueSh0aGlzLl8kaGFuZGxlcnNbaV0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5fYWN0aXZlQ291bnQ7IF9pKyspIHtcbiAgICAgIHRoaXMuX3NvdXJjZXNbX2ldLm9uQW55KHRoaXMuXyRoYW5kbGVyc1tfaV0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0QWZ0ZXJBY3RpdmF0aW9uKSB7XG4gICAgICB0aGlzLl9lbWl0QWZ0ZXJBY3RpdmF0aW9uID0gZmFsc2U7XG4gICAgICB0aGlzLl9lbWl0SWZGdWxsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbmRBZnRlckFjdGl2YXRpb24pIHtcbiAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICB9XG4gIH0sXG4gIF9vbkRlYWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9zb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgaSA9IHZvaWQgMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3NvdXJjZXNbaV0ub2ZmQW55KHRoaXMuXyRoYW5kbGVyc1tpXSk7XG4gICAgfVxuICB9LFxuICBfZW1pdElmRnVsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNBbGxWYWx1ZXMgPSB0cnVlO1xuICAgIHZhciBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGF0ZXN0VmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzQ29weSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIHZhciBlcnJvcnNDb3B5ID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNDb3B5W2ldID0gdGhpcy5fbGF0ZXN0VmFsdWVzW2ldO1xuICAgICAgZXJyb3JzQ29weVtpXSA9IHRoaXMuX2xhdGVzdEVycm9yc1tpXTtcblxuICAgICAgaWYgKHZhbHVlc0NvcHlbaV0gPT09IE5PVEhJTkcpIHtcbiAgICAgICAgaGFzQWxsVmFsdWVzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvcnNDb3B5W2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzQWxsVmFsdWVzKSB7XG4gICAgICB2YXIgY29tYmluYXRvciA9IHRoaXMuX2NvbWJpbmF0b3I7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoY29tYmluYXRvcih2YWx1ZXNDb3B5KSk7XG4gICAgfVxuICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihkZWZhdWx0RXJyb3JzQ29tYmluYXRvcihlcnJvcnNDb3B5KSk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlQW55OiBmdW5jdGlvbiAoaSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gVkFMVUUgfHwgZXZlbnQudHlwZSA9PT0gRVJST1IpIHtcbiAgICAgIGlmIChldmVudC50eXBlID09PSBWQUxVRSkge1xuICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZXNbaV0gPSBldmVudC52YWx1ZTtcbiAgICAgICAgdGhpcy5fbGF0ZXN0RXJyb3JzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEVSUk9SKSB7XG4gICAgICAgIHRoaXMuX2xhdGVzdFZhbHVlc1tpXSA9IE5PVEhJTkc7XG4gICAgICAgIHRoaXMuX2xhdGVzdEVycm9yc1tpXSA9IHtcbiAgICAgICAgICBpbmRleDogdGhpcy5fbGF0ZXN0RXJyb3JJbmRleCsrLFxuICAgICAgICAgIGVycm9yOiBldmVudC52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IHRoaXMuX2FjdGl2ZUNvdW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmF0aW5nKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdEFmdGVyQWN0aXZhdGlvbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZW1pdElmRnVsbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVORFxuXG4gICAgICBpZiAoaSA8IHRoaXMuX2FjdGl2ZUNvdW50KSB7XG4gICAgICAgIHRoaXMuX2FsaXZlQ291bnQtLTtcbiAgICAgICAgaWYgKHRoaXMuX2FsaXZlQ291bnQgPT09IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgICAgICAgdGhpcy5fZW5kQWZ0ZXJBY3RpdmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW1pdEVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgU3RyZWFtLnByb3RvdHlwZS5fY2xlYXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbnVsbDtcbiAgICB0aGlzLl9sYXRlc3RWYWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX2xhdGVzdEVycm9ycyA9IG51bGw7XG4gICAgdGhpcy5fY29tYmluYXRvciA9IG51bGw7XG4gICAgdGhpcy5fJGhhbmRsZXJzID0gbnVsbDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvbWJpbmVBc0FycmF5KGFjdGl2ZSkge1xuICB2YXIgcGFzc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIHZhciBjb21iaW5hdG9yID0gYXJndW1lbnRzWzJdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShwYXNzaXZlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29tYmluZSBjYW4gb25seSBjb21iaW5lIGFjdGl2ZSBhbmQgcGFzc2l2ZSBjb2xsZWN0aW9ucyBvZiB0aGUgc2FtZSB0eXBlLicpO1xuICB9XG5cbiAgY29tYmluYXRvciA9IGNvbWJpbmF0b3IgPyBzcHJlYWQoY29tYmluYXRvciwgYWN0aXZlLmxlbmd0aCArIHBhc3NpdmUubGVuZ3RoKSA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG4gIHJldHVybiBhY3RpdmUubGVuZ3RoID09PSAwID8gbmV2ZXIoKSA6IG5ldyBDb21iaW5lKGFjdGl2ZSwgcGFzc2l2ZSwgY29tYmluYXRvcik7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBc09iamVjdChhY3RpdmUpIHtcbiAgdmFyIHBhc3NpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgY29tYmluYXRvciA9IGFyZ3VtZW50c1syXTtcblxuICBpZiAodHlwZW9mIHBhc3NpdmUgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkocGFzc2l2ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbWJpbmUgY2FuIG9ubHkgY29tYmluZSBhY3RpdmUgYW5kIHBhc3NpdmUgY29sbGVjdGlvbnMgb2YgdGhlIHNhbWUgdHlwZS4nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gW10sXG4gICAgICBhY3RpdmVPYnNlcnZhYmxlcyA9IFtdLFxuICAgICAgcGFzc2l2ZU9ic2VydmFibGVzID0gW107XG5cbiAgY29sbGVjdChhY3RpdmUsIGtleXMsIGFjdGl2ZU9ic2VydmFibGVzKTtcbiAgY29sbGVjdChwYXNzaXZlLCBrZXlzLCBwYXNzaXZlT2JzZXJ2YWJsZXMpO1xuXG4gIHZhciBvYmplY3RpZnkgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgdmFyIGV2ZW50ID0ge307XG4gICAgZm9yICh2YXIgaSA9IHZhbHVlcy5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSkge1xuICAgICAgZXZlbnRba2V5c1tpXV0gPSB2YWx1ZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5hdG9yID8gY29tYmluYXRvcihldmVudCkgOiBldmVudDtcbiAgfTtcblxuICByZXR1cm4gYWN0aXZlT2JzZXJ2YWJsZXMubGVuZ3RoID09PSAwID8gbmV2ZXIoKSA6IG5ldyBDb21iaW5lKGFjdGl2ZU9ic2VydmFibGVzLCBwYXNzaXZlT2JzZXJ2YWJsZXMsIG9iamVjdGlmeSk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmUoYWN0aXZlLCBwYXNzaXZlLCBjb21iaW5hdG9yKSB7XG4gIGlmICh0eXBlb2YgcGFzc2l2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbWJpbmF0b3IgPSBwYXNzaXZlO1xuICAgIHBhc3NpdmUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuaXNBcnJheShhY3RpdmUpID8gY29tYmluZUFzQXJyYXkoYWN0aXZlLCBwYXNzaXZlLCBjb21iaW5hdG9yKSA6IGNvbWJpbmVBc09iamVjdChhY3RpdmUsIHBhc3NpdmUsIGNvbWJpbmF0b3IpO1xufVxuXG52YXIgT2JzZXJ2YWJsZSQyID0ge1xuICBlbXB0eTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXZlcigpO1xuICB9LFxuXG5cbiAgLy8gTW9ub2lkIGJhc2VkIG9uIG1lcmdlKCkgc2VlbXMgbW9yZSB1c2VmdWwgdGhhbiBvbmUgYmFzZWQgb24gY29uY2F0KCkuXG4gIGNvbmNhdDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5tZXJnZShiKTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGNvbnN0YW50KHgpO1xuICB9LFxuICBtYXA6IGZ1bmN0aW9uIChmbiwgb2JzKSB7XG4gICAgcmV0dXJuIG9icy5tYXAoZm4pO1xuICB9LFxuICBiaW1hcDogZnVuY3Rpb24gKGZuRXJyLCBmblZhbCwgb2JzKSB7XG4gICAgcmV0dXJuIG9icy5tYXBFcnJvcnMoZm5FcnIpLm1hcChmblZhbCk7XG4gIH0sXG5cblxuICAvLyBUaGlzIGFwIHN0cmljdGx5IHNwZWFraW5nIGluY29tcGF0aWJsZSB3aXRoIGNoYWluLiBJZiB3ZSBkZXJpdmUgYXAgZnJvbSBjaGFpbiB3ZSBnZXRcbiAgLy8gZGlmZmVyZW50IChub3QgdmVyeSB1c2VmdWwpIGJlaGF2aW9yLiBCdXQgc3BlYyByZXF1aXJlcyB0aGF0IGlmIG1ldGhvZCBjYW4gYmUgZGVyaXZlZFxuICAvLyBpdCBtdXN0IGhhdmUgdGhlIHNhbWUgYmVoYXZpb3IgYXMgaGFuZC13cml0dGVuIG1ldGhvZC4gV2UgaW50ZW50aW9uYWxseSB2aW9sYXRlIHRoZSBzcGVjXG4gIC8vIGluIGhvcGUgdGhhdCBpdCB3b24ndCBjYXVzZSBtYW55IHRyb3VibGVzIGluIHByYWN0aWNlLiBBbmQgaW4gcmV0dXJuIHdlIGhhdmUgbW9yZSB1c2VmdWwgdHlwZS5cbiAgYXA6IGZ1bmN0aW9uIChvYnNGbiwgb2JzVmFsKSB7XG4gICAgcmV0dXJuIGNvbWJpbmUoW29ic0ZuLCBvYnNWYWxdLCBmdW5jdGlvbiAoZm4sIHZhbCkge1xuICAgICAgcmV0dXJuIGZuKHZhbCk7XG4gICAgfSk7XG4gIH0sXG4gIGNoYWluOiBmdW5jdGlvbiAoZm4sIG9icykge1xuICAgIHJldHVybiBvYnMuZmxhdE1hcChmbik7XG4gIH1cbn07XG5cblxuXG52YXIgc3RhdGljTGFuZCA9IE9iamVjdC5mcmVlemUoe1xuXHRPYnNlcnZhYmxlOiBPYnNlcnZhYmxlJDJcbn0pO1xuXG52YXIgbWl4aW4gPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIHRoaXMuX2VtaXRWYWx1ZShmbih4KSk7XG4gIH1cbn07XG5cbnZhciBTJDcgPSBjcmVhdGVTdHJlYW0oJ21hcCcsIG1peGluKTtcbnZhciBQJDMgPSBjcmVhdGVQcm9wZXJ0eSgnbWFwJywgbWl4aW4pO1xuXG52YXIgaWQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIG1hcCQxKG9icykge1xuICB2YXIgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGlkO1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDcsIFAkMykpKG9icywgeyBmbjogZm4gfSk7XG59XG5cbnZhciBtaXhpbiQxID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZm4gPSBfcmVmLmZuO1xuXG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mbiA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgZm4gPSB0aGlzLl9mbjtcbiAgICBpZiAoZm4oeCkpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh4KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBTJDggPSBjcmVhdGVTdHJlYW0oJ2ZpbHRlcicsIG1peGluJDEpO1xudmFyIFAkNCA9IGNyZWF0ZVByb3BlcnR5KCdmaWx0ZXInLCBtaXhpbiQxKTtcblxudmFyIGlkJDEgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlcihvYnMpIHtcbiAgdmFyIGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpZCQxO1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDgsIFAkNCkpKG9icywgeyBmbjogZm4gfSk7XG59XG5cbnZhciBtaXhpbiQyID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbiA9IF9yZWYubjtcblxuICAgIHRoaXMuX24gPSBuO1xuICAgIGlmIChuIDw9IDApIHtcbiAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fbiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9uLS07XG4gICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIGlmICh0aGlzLl9uID09PSAwKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQ5ID0gY3JlYXRlU3RyZWFtKCd0YWtlJywgbWl4aW4kMik7XG52YXIgUCQ1ID0gY3JlYXRlUHJvcGVydHkoJ3Rha2UnLCBtaXhpbiQyKTtcblxuZnVuY3Rpb24gdGFrZShvYnMsIG4pIHtcbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkOSwgUCQ1KSkob2JzLCB7IG46IG4gfSk7XG59XG5cbnZhciBtaXhpbiQzID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbiA9IF9yZWYubjtcblxuICAgIHRoaXMuX24gPSBuO1xuICAgIGlmIChuIDw9IDApIHtcbiAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVFcnJvcjogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fbiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9uLS07XG4gICAgdGhpcy5fZW1pdEVycm9yKHgpO1xuICAgIGlmICh0aGlzLl9uID09PSAwKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxMCA9IGNyZWF0ZVN0cmVhbSgndGFrZUVycm9ycycsIG1peGluJDMpO1xudmFyIFAkNiA9IGNyZWF0ZVByb3BlcnR5KCd0YWtlRXJyb3JzJywgbWl4aW4kMyk7XG5cbmZ1bmN0aW9uIHRha2VFcnJvcnMob2JzLCBuKSB7XG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDEwLCBQJDYpKShvYnMsIHsgbjogbiB9KTtcbn1cblxudmFyIG1peGluJDQgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIGlmIChmbih4KSkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxMSA9IGNyZWF0ZVN0cmVhbSgndGFrZVdoaWxlJywgbWl4aW4kNCk7XG52YXIgUCQ3ID0gY3JlYXRlUHJvcGVydHkoJ3Rha2VXaGlsZScsIG1peGluJDQpO1xuXG52YXIgaWQkMiA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB4O1xufTtcblxuZnVuY3Rpb24gdGFrZVdoaWxlKG9icykge1xuICB2YXIgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGlkJDI7XG5cbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMTEsIFAkNykpKG9icywgeyBmbjogZm4gfSk7XG59XG5cbnZhciBtaXhpbiQ1ID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2xhc3RWYWx1ZSA9IE5PVEhJTkc7XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbGFzdFZhbHVlID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHRoaXMuX2xhc3RWYWx1ZSA9IHg7XG4gIH0sXG4gIF9oYW5kbGVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fbGFzdFZhbHVlICE9PSBOT1RISU5HKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUodGhpcy5fbGFzdFZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5fZW1pdEVuZCgpO1xuICB9XG59O1xuXG52YXIgUyQxMiA9IGNyZWF0ZVN0cmVhbSgnbGFzdCcsIG1peGluJDUpO1xudmFyIFAkOCA9IGNyZWF0ZVByb3BlcnR5KCdsYXN0JywgbWl4aW4kNSk7XG5cbmZ1bmN0aW9uIGxhc3Qob2JzKSB7XG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDEyLCBQJDgpKShvYnMpO1xufVxuXG52YXIgbWl4aW4kNiA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG4gPSBfcmVmLm47XG5cbiAgICB0aGlzLl9uID0gTWF0aC5tYXgoMCwgbik7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fbiA9PT0gMCkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9uLS07XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxMyA9IGNyZWF0ZVN0cmVhbSgnc2tpcCcsIG1peGluJDYpO1xudmFyIFAkOSA9IGNyZWF0ZVByb3BlcnR5KCdza2lwJywgbWl4aW4kNik7XG5cbmZ1bmN0aW9uIHNraXAob2JzLCBuKSB7XG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDEzLCBQJDkpKShvYnMsIHsgbjogbiB9KTtcbn1cblxudmFyIG1peGluJDcgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIGlmICh0aGlzLl9mbiAhPT0gbnVsbCAmJiAhZm4oeCkpIHtcbiAgICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZuID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoeCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxNCA9IGNyZWF0ZVN0cmVhbSgnc2tpcFdoaWxlJywgbWl4aW4kNyk7XG52YXIgUCQxMCA9IGNyZWF0ZVByb3BlcnR5KCdza2lwV2hpbGUnLCBtaXhpbiQ3KTtcblxudmFyIGlkJDMgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIHNraXBXaGlsZShvYnMpIHtcbiAgdmFyIGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpZCQzO1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDE0LCBQJDEwKSkob2JzLCB7IGZuOiBmbiB9KTtcbn1cblxudmFyIG1peGluJDggPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICAgIHRoaXMuX3ByZXYgPSBOT1RISU5HO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIGlmICh0aGlzLl9wcmV2ID09PSBOT1RISU5HIHx8ICFmbih0aGlzLl9wcmV2LCB4KSkge1xuICAgICAgdGhpcy5fcHJldiA9IHg7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoeCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxNSA9IGNyZWF0ZVN0cmVhbSgnc2tpcER1cGxpY2F0ZXMnLCBtaXhpbiQ4KTtcbnZhciBQJDExID0gY3JlYXRlUHJvcGVydHkoJ3NraXBEdXBsaWNhdGVzJywgbWl4aW4kOCk7XG5cbnZhciBlcSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufTtcblxuZnVuY3Rpb24gc2tpcER1cGxpY2F0ZXMob2JzKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZXE7XG5cbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMTUsIFAkMTEpKShvYnMsIHsgZm46IGZuIH0pO1xufVxuXG52YXIgbWl4aW4kOSA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGZuID0gX3JlZi5mbixcbiAgICAgICAgc2VlZCA9IF9yZWYuc2VlZDtcblxuICAgIHRoaXMuX2ZuID0gZm47XG4gICAgdGhpcy5fcHJldiA9IHNlZWQ7XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgdGhpcy5fZm4gPSBudWxsO1xuICB9LFxuICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHRoaXMuX3ByZXYgIT09IE5PVEhJTkcpIHtcbiAgICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKGZuKHRoaXMuX3ByZXYsIHgpKTtcbiAgICB9XG4gICAgdGhpcy5fcHJldiA9IHg7XG4gIH1cbn07XG5cbnZhciBTJDE2ID0gY3JlYXRlU3RyZWFtKCdkaWZmJywgbWl4aW4kOSk7XG52YXIgUCQxMiA9IGNyZWF0ZVByb3BlcnR5KCdkaWZmJywgbWl4aW4kOSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRGbihhLCBiKSB7XG4gIHJldHVybiBbYSwgYl07XG59XG5cbmZ1bmN0aW9uIGRpZmYob2JzLCBmbikge1xuICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogTk9USElORztcblxuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQxNiwgUCQxMikpKG9icywgeyBmbjogZm4gfHwgZGVmYXVsdEZuLCBzZWVkOiBzZWVkIH0pO1xufVxuXG52YXIgUCQxMyA9IGNyZWF0ZVByb3BlcnR5KCdzY2FuJywge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZm4gPSBfcmVmLmZuLFxuICAgICAgICBzZWVkID0gX3JlZi5zZWVkO1xuXG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgICB0aGlzLl9zZWVkID0gc2VlZDtcbiAgICBpZiAoc2VlZCAhPT0gTk9USElORykge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHNlZWQpO1xuICAgIH1cbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mbiA9IG51bGw7XG4gICAgdGhpcy5fc2VlZCA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgZm4gPSB0aGlzLl9mbjtcbiAgICBpZiAodGhpcy5fY3VycmVudEV2ZW50ID09PSBudWxsIHx8IHRoaXMuX2N1cnJlbnRFdmVudC50eXBlID09PSBFUlJPUikge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHRoaXMuX3NlZWQgPT09IE5PVEhJTkcgPyB4IDogZm4odGhpcy5fc2VlZCwgeCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoZm4odGhpcy5fY3VycmVudEV2ZW50LnZhbHVlLCB4KSk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gc2NhbihvYnMsIGZuKSB7XG4gIHZhciBzZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBOT1RISU5HO1xuXG4gIHJldHVybiBuZXcgUCQxMyhvYnMsIHsgZm46IGZuLCBzZWVkOiBzZWVkIH0pO1xufVxuXG52YXIgbWl4aW4kMTAgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIHZhciB4cyA9IGZuKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh4c1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxNyA9IGNyZWF0ZVN0cmVhbSgnZmxhdHRlbicsIG1peGluJDEwKTtcblxudmFyIGlkJDQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JzKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogaWQkNDtcblxuICByZXR1cm4gbmV3IFMkMTcob2JzLCB7IGZuOiBmbiB9KTtcbn1cblxudmFyIEVORF9NQVJLRVIgPSB7fTtcblxudmFyIG1peGluJDExID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHdhaXQgPSBfcmVmLndhaXQ7XG5cbiAgICB0aGlzLl93YWl0ID0gTWF0aC5tYXgoMCwgd2FpdCk7XG4gICAgdGhpcy5fYnVmZiA9IFtdO1xuICAgIHRoaXMuXyRzaGlmdEJ1ZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBfdGhpcy5fYnVmZi5zaGlmdCgpO1xuICAgICAgaWYgKHZhbHVlID09PSBFTkRfTUFSS0VSKSB7XG4gICAgICAgIF90aGlzLl9lbWl0RW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5fZW1pdFZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2J1ZmYgPSBudWxsO1xuICAgIHRoaXMuXyRzaGlmdEJ1ZmYgPSBudWxsO1xuICB9LFxuICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2YXRpbmcpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnVmZi5wdXNoKHgpO1xuICAgICAgc2V0VGltZW91dCh0aGlzLl8kc2hpZnRCdWZmLCB0aGlzLl93YWl0KTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgdGhpcy5fZW1pdEVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZmLnB1c2goRU5EX01BUktFUik7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMuXyRzaGlmdEJ1ZmYsIHRoaXMuX3dhaXQpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFMkMTggPSBjcmVhdGVTdHJlYW0oJ2RlbGF5JywgbWl4aW4kMTEpO1xudmFyIFAkMTQgPSBjcmVhdGVQcm9wZXJ0eSgnZGVsYXknLCBtaXhpbiQxMSk7XG5cbmZ1bmN0aW9uIGRlbGF5KG9icywgd2FpdCkge1xuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQxOCwgUCQxNCkpKG9icywgeyB3YWl0OiB3YWl0IH0pO1xufVxuXG52YXIgbm93ID0gRGF0ZS5ub3cgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufTtcblxudmFyIG1peGluJDEyID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHdhaXQgPSBfcmVmLndhaXQsXG4gICAgICAgIGxlYWRpbmcgPSBfcmVmLmxlYWRpbmcsXG4gICAgICAgIHRyYWlsaW5nID0gX3JlZi50cmFpbGluZztcblxuICAgIHRoaXMuX3dhaXQgPSBNYXRoLm1heCgwLCB3YWl0KTtcbiAgICB0aGlzLl9sZWFkaW5nID0gbGVhZGluZztcbiAgICB0aGlzLl90cmFpbGluZyA9IHRyYWlsaW5nO1xuICAgIHRoaXMuX3RyYWlsaW5nVmFsdWUgPSBudWxsO1xuICAgIHRoaXMuX3RpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5fZW5kTGF0ZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0Q2FsbFRpbWUgPSAwO1xuICAgIHRoaXMuXyR0cmFpbGluZ0NhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuX3RyYWlsaW5nQ2FsbCgpO1xuICAgIH07XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdHJhaWxpbmdWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy5fJHRyYWlsaW5nQ2FsbCA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VyVGltZSA9IG5vdygpO1xuICAgICAgaWYgKHRoaXMuX2xhc3RDYWxsVGltZSA9PT0gMCAmJiAhdGhpcy5fbGVhZGluZykge1xuICAgICAgICB0aGlzLl9sYXN0Q2FsbFRpbWUgPSBjdXJUaW1lO1xuICAgICAgfVxuICAgICAgdmFyIHJlbWFpbmluZyA9IHRoaXMuX3dhaXQgLSAoY3VyVGltZSAtIHRoaXMuX2xhc3RDYWxsVGltZSk7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsVHJhaWxpbmcoKTtcbiAgICAgICAgdGhpcy5fbGFzdENhbGxUaW1lID0gY3VyVGltZTtcbiAgICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl90cmFpbGluZykge1xuICAgICAgICB0aGlzLl9jYW5jZWxUcmFpbGluZygpO1xuICAgICAgICB0aGlzLl90cmFpbGluZ1ZhbHVlID0geDtcbiAgICAgICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl8kdHJhaWxpbmdDYWxsLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2hhbmRsZUVuZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmF0aW5nKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl90aW1lb3V0SWQpIHtcbiAgICAgICAgdGhpcy5fZW5kTGF0ZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW1pdEVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NhbmNlbFRyYWlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7XG4gICAgICB0aGlzLl90aW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgX3RyYWlsaW5nQ2FsbDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2VtaXRWYWx1ZSh0aGlzLl90cmFpbGluZ1ZhbHVlKTtcbiAgICB0aGlzLl90aW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMuX3RyYWlsaW5nVmFsdWUgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RDYWxsVGltZSA9ICF0aGlzLl9sZWFkaW5nID8gMCA6IG5vdygpO1xuICAgIGlmICh0aGlzLl9lbmRMYXRlcikge1xuICAgICAgdGhpcy5fZW1pdEVuZCgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFMkMTkgPSBjcmVhdGVTdHJlYW0oJ3Rocm90dGxlJywgbWl4aW4kMTIpO1xudmFyIFAkMTUgPSBjcmVhdGVQcm9wZXJ0eSgndGhyb3R0bGUnLCBtaXhpbiQxMik7XG5cbmZ1bmN0aW9uIHRocm90dGxlKG9icywgd2FpdCkge1xuICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgX3JlZjIkbGVhZGluZyA9IF9yZWYyLmxlYWRpbmcsXG4gICAgICBsZWFkaW5nID0gX3JlZjIkbGVhZGluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYyJGxlYWRpbmcsXG4gICAgICBfcmVmMiR0cmFpbGluZyA9IF9yZWYyLnRyYWlsaW5nLFxuICAgICAgdHJhaWxpbmcgPSBfcmVmMiR0cmFpbGluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYyJHRyYWlsaW5nO1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDE5LCBQJDE1KSkob2JzLCB7IHdhaXQ6IHdhaXQsIGxlYWRpbmc6IGxlYWRpbmcsIHRyYWlsaW5nOiB0cmFpbGluZyB9KTtcbn1cblxudmFyIG1peGluJDEzID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHdhaXQgPSBfcmVmLndhaXQsXG4gICAgICAgIGltbWVkaWF0ZSA9IF9yZWYuaW1tZWRpYXRlO1xuXG4gICAgdGhpcy5fd2FpdCA9IE1hdGgubWF4KDAsIHdhaXQpO1xuICAgIHRoaXMuX2ltbWVkaWF0ZSA9IGltbWVkaWF0ZTtcbiAgICB0aGlzLl9sYXN0QXR0ZW1wdCA9IDA7XG4gICAgdGhpcy5fdGltZW91dElkID0gbnVsbDtcbiAgICB0aGlzLl9sYXRlclZhbHVlID0gbnVsbDtcbiAgICB0aGlzLl9lbmRMYXRlciA9IGZhbHNlO1xuICAgIHRoaXMuXyRsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fbGF0ZXIoKTtcbiAgICB9O1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2xhdGVyVmFsdWUgPSBudWxsO1xuICAgIHRoaXMuXyRsYXRlciA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sYXN0QXR0ZW1wdCA9IG5vdygpO1xuICAgICAgaWYgKHRoaXMuX2ltbWVkaWF0ZSAmJiAhdGhpcy5fdGltZW91dElkKSB7XG4gICAgICAgIHRoaXMuX2VtaXRWYWx1ZSh4KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fdGltZW91dElkKSB7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fJGxhdGVyLCB0aGlzLl93YWl0KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5faW1tZWRpYXRlKSB7XG4gICAgICAgIHRoaXMuX2xhdGVyVmFsdWUgPSB4O1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2hhbmRsZUVuZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmF0aW5nKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl90aW1lb3V0SWQgJiYgIXRoaXMuX2ltbWVkaWF0ZSkge1xuICAgICAgICB0aGlzLl9lbmRMYXRlciA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfbGF0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdCA9IG5vdygpIC0gdGhpcy5fbGFzdEF0dGVtcHQ7XG4gICAgaWYgKGxhc3QgPCB0aGlzLl93YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl8kbGF0ZXIsIHRoaXMuX3dhaXQgLSBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGltZW91dElkID0gbnVsbDtcbiAgICAgIGlmICghdGhpcy5faW1tZWRpYXRlKSB7XG4gICAgICAgIHRoaXMuX2VtaXRWYWx1ZSh0aGlzLl9sYXRlclZhbHVlKTtcbiAgICAgICAgdGhpcy5fbGF0ZXJWYWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZW5kTGF0ZXIpIHtcbiAgICAgICAgdGhpcy5fZW1pdEVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIFMkMjAgPSBjcmVhdGVTdHJlYW0oJ2RlYm91bmNlJywgbWl4aW4kMTMpO1xudmFyIFAkMTYgPSBjcmVhdGVQcm9wZXJ0eSgnZGVib3VuY2UnLCBtaXhpbiQxMyk7XG5cbmZ1bmN0aW9uIGRlYm91bmNlKG9icywgd2FpdCkge1xuICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgX3JlZjIkaW1tZWRpYXRlID0gX3JlZjIuaW1tZWRpYXRlLFxuICAgICAgaW1tZWRpYXRlID0gX3JlZjIkaW1tZWRpYXRlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYyJGltbWVkaWF0ZTtcblxuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQyMCwgUCQxNikpKG9icywgeyB3YWl0OiB3YWl0LCBpbW1lZGlhdGU6IGltbWVkaWF0ZSB9KTtcbn1cblxudmFyIG1peGluJDE0ID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZm4gPSBfcmVmLmZuO1xuXG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mbiA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVFcnJvcjogZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgZm4gPSB0aGlzLl9mbjtcbiAgICB0aGlzLl9lbWl0RXJyb3IoZm4oeCkpO1xuICB9XG59O1xuXG52YXIgUyQyMSA9IGNyZWF0ZVN0cmVhbSgnbWFwRXJyb3JzJywgbWl4aW4kMTQpO1xudmFyIFAkMTcgPSBjcmVhdGVQcm9wZXJ0eSgnbWFwRXJyb3JzJywgbWl4aW4kMTQpO1xuXG52YXIgaWQkNSA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB4O1xufTtcblxuZnVuY3Rpb24gbWFwRXJyb3JzKG9icykge1xuICB2YXIgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGlkJDU7XG5cbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMjEsIFAkMTcpKShvYnMsIHsgZm46IGZuIH0pO1xufVxuXG52YXIgbWl4aW4kMTUgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZUVycm9yOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIGlmIChmbih4KSkge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKHgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFMkMjIgPSBjcmVhdGVTdHJlYW0oJ2ZpbHRlckVycm9ycycsIG1peGluJDE1KTtcbnZhciBQJDE4ID0gY3JlYXRlUHJvcGVydHkoJ2ZpbHRlckVycm9ycycsIG1peGluJDE1KTtcblxudmFyIGlkJDYgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlckVycm9ycyhvYnMpIHtcbiAgdmFyIGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpZCQ2O1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDIyLCBQJDE4KSkob2JzLCB7IGZuOiBmbiB9KTtcbn1cblxudmFyIG1peGluJDE2ID0ge1xuICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG52YXIgUyQyMyA9IGNyZWF0ZVN0cmVhbSgnaWdub3JlVmFsdWVzJywgbWl4aW4kMTYpO1xudmFyIFAkMTkgPSBjcmVhdGVQcm9wZXJ0eSgnaWdub3JlVmFsdWVzJywgbWl4aW4kMTYpO1xuXG5mdW5jdGlvbiBpZ25vcmVWYWx1ZXMob2JzKSB7XG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDIzLCBQJDE5KSkob2JzKTtcbn1cblxudmFyIG1peGluJDE3ID0ge1xuICBfaGFuZGxlRXJyb3I6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG52YXIgUyQyNCA9IGNyZWF0ZVN0cmVhbSgnaWdub3JlRXJyb3JzJywgbWl4aW4kMTcpO1xudmFyIFAkMjAgPSBjcmVhdGVQcm9wZXJ0eSgnaWdub3JlRXJyb3JzJywgbWl4aW4kMTcpO1xuXG5mdW5jdGlvbiBpZ25vcmVFcnJvcnMob2JzKSB7XG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDI0LCBQJDIwKSkob2JzKTtcbn1cblxudmFyIG1peGluJDE4ID0ge1xuICBfaGFuZGxlRW5kOiBmdW5jdGlvbiAoKSB7fVxufTtcblxudmFyIFMkMjUgPSBjcmVhdGVTdHJlYW0oJ2lnbm9yZUVuZCcsIG1peGluJDE4KTtcbnZhciBQJDIxID0gY3JlYXRlUHJvcGVydHkoJ2lnbm9yZUVuZCcsIG1peGluJDE4KTtcblxuZnVuY3Rpb24gaWdub3JlRW5kKG9icykge1xuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQyNSwgUCQyMSkpKG9icyk7XG59XG5cbnZhciBtaXhpbiQxOSA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGZuID0gX3JlZi5mbjtcblxuICAgIHRoaXMuX2ZuID0gZm47XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZm4gPSBudWxsO1xuICB9LFxuICBfaGFuZGxlRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZuID0gdGhpcy5fZm47XG4gICAgdGhpcy5fZW1pdFZhbHVlKGZuKCkpO1xuICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgfVxufTtcblxudmFyIFMkMjYgPSBjcmVhdGVTdHJlYW0oJ2JlZm9yZUVuZCcsIG1peGluJDE5KTtcbnZhciBQJDIyID0gY3JlYXRlUHJvcGVydHkoJ2JlZm9yZUVuZCcsIG1peGluJDE5KTtcblxuZnVuY3Rpb24gYmVmb3JlRW5kKG9icywgZm4pIHtcbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMjYsIFAkMjIpKShvYnMsIHsgZm46IGZuIH0pO1xufVxuXG52YXIgbWl4aW4kMjAgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBtaW4gPSBfcmVmLm1pbixcbiAgICAgICAgbWF4ID0gX3JlZi5tYXg7XG5cbiAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgdGhpcy5fbWluID0gbWluO1xuICAgIHRoaXMuX2J1ZmYgPSBbXTtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9idWZmID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHRoaXMuX2J1ZmYgPSBzbGlkZSh0aGlzLl9idWZmLCB4LCB0aGlzLl9tYXgpO1xuICAgIGlmICh0aGlzLl9idWZmLmxlbmd0aCA+PSB0aGlzLl9taW4pIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh0aGlzLl9idWZmKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBTJDI3ID0gY3JlYXRlU3RyZWFtKCdzbGlkaW5nV2luZG93JywgbWl4aW4kMjApO1xudmFyIFAkMjMgPSBjcmVhdGVQcm9wZXJ0eSgnc2xpZGluZ1dpbmRvdycsIG1peGluJDIwKTtcblxuZnVuY3Rpb24gc2xpZGluZ1dpbmRvdyhvYnMsIG1heCkge1xuICB2YXIgbWluID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDI3LCBQJDIzKSkob2JzLCB7IG1pbjogbWluLCBtYXg6IG1heCB9KTtcbn1cblxudmFyIG1peGluJDIxID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZm4gPSBfcmVmLmZuLFxuICAgICAgICBmbHVzaE9uRW5kID0gX3JlZi5mbHVzaE9uRW5kO1xuXG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgICB0aGlzLl9mbHVzaE9uRW5kID0gZmx1c2hPbkVuZDtcbiAgICB0aGlzLl9idWZmID0gW107XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYnVmZiA9IG51bGw7XG4gIH0sXG4gIF9mbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9idWZmICE9PSBudWxsICYmIHRoaXMuX2J1ZmYubGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUodGhpcy5fYnVmZik7XG4gICAgICB0aGlzLl9idWZmID0gW107XG4gICAgfVxuICB9LFxuICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgdGhpcy5fYnVmZi5wdXNoKHgpO1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIGlmICghZm4oeCkpIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2ZsdXNoT25FbmQpIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgfVxufTtcblxudmFyIFMkMjggPSBjcmVhdGVTdHJlYW0oJ2J1ZmZlcldoaWxlJywgbWl4aW4kMjEpO1xudmFyIFAkMjQgPSBjcmVhdGVQcm9wZXJ0eSgnYnVmZmVyV2hpbGUnLCBtaXhpbiQyMSk7XG5cbnZhciBpZCQ3ID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG5mdW5jdGlvbiBidWZmZXJXaGlsZShvYnMsIGZuKSB7XG4gIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICBfcmVmMiRmbHVzaE9uRW5kID0gX3JlZjIuZmx1c2hPbkVuZCxcbiAgICAgIGZsdXNoT25FbmQgPSBfcmVmMiRmbHVzaE9uRW5kID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZjIkZmx1c2hPbkVuZDtcblxuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQyOCwgUCQyNCkpKG9icywgeyBmbjogZm4gfHwgaWQkNywgZmx1c2hPbkVuZDogZmx1c2hPbkVuZCB9KTtcbn1cblxudmFyIG1peGluJDIyID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgY291bnQgPSBfcmVmLmNvdW50LFxuICAgICAgICBmbHVzaE9uRW5kID0gX3JlZi5mbHVzaE9uRW5kO1xuXG4gICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICB0aGlzLl9mbHVzaE9uRW5kID0gZmx1c2hPbkVuZDtcbiAgICB0aGlzLl9idWZmID0gW107XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYnVmZiA9IG51bGw7XG4gIH0sXG4gIF9mbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9idWZmICE9PSBudWxsICYmIHRoaXMuX2J1ZmYubGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUodGhpcy5fYnVmZik7XG4gICAgICB0aGlzLl9idWZmID0gW107XG4gICAgfVxuICB9LFxuICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgdGhpcy5fYnVmZi5wdXNoKHgpO1xuICAgIGlmICh0aGlzLl9idWZmLmxlbmd0aCA+PSB0aGlzLl9jb3VudCkge1xuICAgICAgdGhpcy5fZmx1c2goKTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmx1c2hPbkVuZCkge1xuICAgICAgdGhpcy5fZmx1c2goKTtcbiAgICB9XG4gICAgdGhpcy5fZW1pdEVuZCgpO1xuICB9XG59O1xuXG52YXIgUyQyOSA9IGNyZWF0ZVN0cmVhbSgnYnVmZmVyV2l0aENvdW50JywgbWl4aW4kMjIpO1xudmFyIFAkMjUgPSBjcmVhdGVQcm9wZXJ0eSgnYnVmZmVyV2l0aENvdW50JywgbWl4aW4kMjIpO1xuXG5mdW5jdGlvbiBidWZmZXJXaGlsZSQxKG9icywgY291bnQpIHtcbiAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgIF9yZWYyJGZsdXNoT25FbmQgPSBfcmVmMi5mbHVzaE9uRW5kLFxuICAgICAgZmx1c2hPbkVuZCA9IF9yZWYyJGZsdXNoT25FbmQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmMiRmbHVzaE9uRW5kO1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDI5LCBQJDI1KSkob2JzLCB7IGNvdW50OiBjb3VudCwgZmx1c2hPbkVuZDogZmx1c2hPbkVuZCB9KTtcbn1cblxudmFyIG1peGluJDIzID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHdhaXQgPSBfcmVmLndhaXQsXG4gICAgICAgIGNvdW50ID0gX3JlZi5jb3VudCxcbiAgICAgICAgZmx1c2hPbkVuZCA9IF9yZWYuZmx1c2hPbkVuZDtcblxuICAgIHRoaXMuX3dhaXQgPSB3YWl0O1xuICAgIHRoaXMuX2NvdW50ID0gY291bnQ7XG4gICAgdGhpcy5fZmx1c2hPbkVuZCA9IGZsdXNoT25FbmQ7XG4gICAgdGhpcy5faW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgdGhpcy5fJG9uVGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fZmx1c2goKTtcbiAgICB9O1xuICAgIHRoaXMuX2J1ZmYgPSBbXTtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl8kb25UaWNrID0gbnVsbDtcbiAgICB0aGlzLl9idWZmID0gbnVsbDtcbiAgfSxcbiAgX2ZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmYgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh0aGlzLl9idWZmKTtcbiAgICAgIHRoaXMuX2J1ZmYgPSBbXTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICB0aGlzLl9idWZmLnB1c2goeCk7XG4gICAgaWYgKHRoaXMuX2J1ZmYubGVuZ3RoID49IHRoaXMuX2NvdW50KSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpO1xuICAgICAgdGhpcy5fZmx1c2goKTtcbiAgICAgIHRoaXMuX2ludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh0aGlzLl8kb25UaWNrLCB0aGlzLl93YWl0KTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmx1c2hPbkVuZCAmJiB0aGlzLl9idWZmLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5fZmx1c2goKTtcbiAgICB9XG4gICAgdGhpcy5fZW1pdEVuZCgpO1xuICB9LFxuICBfb25BY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRoaXMuXyRvblRpY2ssIHRoaXMuX3dhaXQpO1xuICAgIHRoaXMuX3NvdXJjZS5vbkFueSh0aGlzLl8kaGFuZGxlQW55KTsgLy8gY29waWVkIGZyb20gcGF0dGVybnMvb25lLXNvdXJjZVxuICB9LFxuICBfb25EZWFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faW50ZXJ2YWxJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbElkKTtcbiAgICAgIHRoaXMuX2ludGVydmFsSWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9zb3VyY2Uub2ZmQW55KHRoaXMuXyRoYW5kbGVBbnkpOyAvLyBjb3BpZWQgZnJvbSBwYXR0ZXJucy9vbmUtc291cmNlXG4gIH1cbn07XG5cbnZhciBTJDMwID0gY3JlYXRlU3RyZWFtKCdidWZmZXJXaXRoVGltZU9yQ291bnQnLCBtaXhpbiQyMyk7XG52YXIgUCQyNiA9IGNyZWF0ZVByb3BlcnR5KCdidWZmZXJXaXRoVGltZU9yQ291bnQnLCBtaXhpbiQyMyk7XG5cbmZ1bmN0aW9uIGJ1ZmZlcldpdGhUaW1lT3JDb3VudChvYnMsIHdhaXQsIGNvdW50KSB7XG4gIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge30sXG4gICAgICBfcmVmMiRmbHVzaE9uRW5kID0gX3JlZjIuZmx1c2hPbkVuZCxcbiAgICAgIGZsdXNoT25FbmQgPSBfcmVmMiRmbHVzaE9uRW5kID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZjIkZmx1c2hPbkVuZDtcblxuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQzMCwgUCQyNikpKG9icywgeyB3YWl0OiB3YWl0LCBjb3VudDogY291bnQsIGZsdXNoT25FbmQ6IGZsdXNoT25FbmQgfSk7XG59XG5cbmZ1bmN0aW9uIHhmb3JtRm9yT2JzKG9icykge1xuICByZXR1cm4ge1xuICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChyZXMsIGlucHV0KSB7XG4gICAgICBvYnMuX2VtaXRWYWx1ZShpbnB1dCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogZnVuY3Rpb24gKCkge1xuICAgICAgb2JzLl9lbWl0RW5kKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbnZhciBtaXhpbiQyNCA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHRyYW5zZHVjZXIgPSBfcmVmLnRyYW5zZHVjZXI7XG5cbiAgICB0aGlzLl94Zm9ybSA9IHRyYW5zZHVjZXIoeGZvcm1Gb3JPYnModGhpcykpO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3hmb3JtID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIGlmICh0aGlzLl94Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShudWxsLCB4KSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5feGZvcm1bJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShudWxsKTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl94Zm9ybVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKG51bGwpO1xuICB9XG59O1xuXG52YXIgUyQzMSA9IGNyZWF0ZVN0cmVhbSgndHJhbnNkdWNlJywgbWl4aW4kMjQpO1xudmFyIFAkMjcgPSBjcmVhdGVQcm9wZXJ0eSgndHJhbnNkdWNlJywgbWl4aW4kMjQpO1xuXG5mdW5jdGlvbiB0cmFuc2R1Y2Uob2JzLCB0cmFuc2R1Y2VyKSB7XG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDMxLCBQJDI3KSkob2JzLCB7IHRyYW5zZHVjZXI6IHRyYW5zZHVjZXIgfSk7XG59XG5cbnZhciBtaXhpbiQyNSA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGZuID0gX3JlZi5mbjtcblxuICAgIHRoaXMuX2hhbmRsZXIgPSBmbjtcbiAgICB0aGlzLl9lbWl0dGVyID0gZW1pdHRlcih0aGlzKTtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9oYW5kbGVyID0gbnVsbDtcbiAgICB0aGlzLl9lbWl0dGVyID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZUFueTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5faGFuZGxlcih0aGlzLl9lbWl0dGVyLCBldmVudCk7XG4gIH1cbn07XG5cbnZhciBTJDMyID0gY3JlYXRlU3RyZWFtKCd3aXRoSGFuZGxlcicsIG1peGluJDI1KTtcbnZhciBQJDI4ID0gY3JlYXRlUHJvcGVydHkoJ3dpdGhIYW5kbGVyJywgbWl4aW4kMjUpO1xuXG5mdW5jdGlvbiB3aXRoSGFuZGxlcihvYnMsIGZuKSB7XG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDMyLCBQJDI4KSkob2JzLCB7IGZuOiBmbiB9KTtcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIFppcChzb3VyY2VzLCBjb21iaW5hdG9yKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5fYnVmZmVycyA9IG1hcChzb3VyY2VzLCBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkoc291cmNlKSA/IGNsb25lQXJyYXkoc291cmNlKSA6IFtdO1xuICB9KTtcbiAgdGhpcy5fc291cmNlcyA9IG1hcChzb3VyY2VzLCBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkoc291cmNlKSA/IG5ldmVyKCkgOiBzb3VyY2U7XG4gIH0pO1xuXG4gIHRoaXMuX2NvbWJpbmF0b3IgPSBjb21iaW5hdG9yID8gc3ByZWFkKGNvbWJpbmF0b3IsIHRoaXMuX3NvdXJjZXMubGVuZ3RoKSA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG4gIHRoaXMuX2FsaXZlQ291bnQgPSAwO1xuXG4gIHRoaXMuXyRoYW5kbGVycyA9IFtdO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgX3RoaXMuXyRoYW5kbGVycy5wdXNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVBbnkoaSwgZXZlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIF9sb29wKGkpO1xuICB9XG59XG5cbmluaGVyaXQoWmlwLCBTdHJlYW0sIHtcbiAgX25hbWU6ICd6aXAnLFxuXG4gIF9vbkFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBpZiBhbGwgc291cmNlcyBhcmUgYXJyYXlzXG4gICAgd2hpbGUgKHRoaXMuX2lzRnVsbCgpKSB7XG4gICAgICB0aGlzLl9lbWl0KCk7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoO1xuICAgIHRoaXMuX2FsaXZlQ291bnQgPSBsZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggJiYgdGhpcy5fYWN0aXZlOyBpKyspIHtcbiAgICAgIHRoaXMuX3NvdXJjZXNbaV0ub25BbnkodGhpcy5fJGhhbmRsZXJzW2ldKTtcbiAgICB9XG4gIH0sXG4gIF9vbkRlYWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fc291cmNlc1tpXS5vZmZBbnkodGhpcy5fJGhhbmRsZXJzW2ldKTtcbiAgICB9XG4gIH0sXG4gIF9lbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLl9idWZmZXJzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSB0aGlzLl9idWZmZXJzW2ldLnNoaWZ0KCk7XG4gICAgfVxuICAgIHZhciBjb21iaW5hdG9yID0gdGhpcy5fY29tYmluYXRvcjtcbiAgICB0aGlzLl9lbWl0VmFsdWUoY29tYmluYXRvcih2YWx1ZXMpKTtcbiAgfSxcbiAgX2lzRnVsbDogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX2J1ZmZlcnNbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIF9oYW5kbGVBbnk6IGZ1bmN0aW9uIChpLCBldmVudCkge1xuICAgIGlmIChldmVudC50eXBlID09PSBWQUxVRSkge1xuICAgICAgdGhpcy5fYnVmZmVyc1tpXS5wdXNoKGV2ZW50LnZhbHVlKTtcbiAgICAgIGlmICh0aGlzLl9pc0Z1bGwoKSkge1xuICAgICAgICB0aGlzLl9lbWl0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSBFUlJPUikge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKGV2ZW50LnZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IEVORCkge1xuICAgICAgdGhpcy5fYWxpdmVDb3VudC0tO1xuICAgICAgaWYgKHRoaXMuX2FsaXZlQ291bnQgPT09IDApIHtcbiAgICAgICAgdGhpcy5fZW1pdEVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgU3RyZWFtLnByb3RvdHlwZS5fY2xlYXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbnVsbDtcbiAgICB0aGlzLl9idWZmZXJzID0gbnVsbDtcbiAgICB0aGlzLl9jb21iaW5hdG9yID0gbnVsbDtcbiAgICB0aGlzLl8kaGFuZGxlcnMgPSBudWxsO1xuICB9XG59KTtcblxuZnVuY3Rpb24gemlwKG9ic2VydmFibGVzLCBjb21iaW5hdG9yIC8qIEZ1bmN0aW9uIHwgZmFsc2V5ICovKSB7XG4gIHJldHVybiBvYnNlcnZhYmxlcy5sZW5ndGggPT09IDAgPyBuZXZlcigpIDogbmV3IFppcChvYnNlcnZhYmxlcywgY29tYmluYXRvcik7XG59XG5cbnZhciBpZCQ4ID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG5mdW5jdGlvbiBBYnN0cmFjdFBvb2woKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgX3JlZiRxdWV1ZUxpbSA9IF9yZWYucXVldWVMaW0sXG4gICAgICBxdWV1ZUxpbSA9IF9yZWYkcXVldWVMaW0gPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHF1ZXVlTGltLFxuICAgICAgX3JlZiRjb25jdXJMaW0gPSBfcmVmLmNvbmN1ckxpbSxcbiAgICAgIGNvbmN1ckxpbSA9IF9yZWYkY29uY3VyTGltID09PSB1bmRlZmluZWQgPyAtMSA6IF9yZWYkY29uY3VyTGltLFxuICAgICAgX3JlZiRkcm9wID0gX3JlZi5kcm9wLFxuICAgICAgZHJvcCA9IF9yZWYkZHJvcCA9PT0gdW5kZWZpbmVkID8gJ25ldycgOiBfcmVmJGRyb3A7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5fcXVldWVMaW0gPSBxdWV1ZUxpbSA8IDAgPyAtMSA6IHF1ZXVlTGltO1xuICB0aGlzLl9jb25jdXJMaW0gPSBjb25jdXJMaW0gPCAwID8gLTEgOiBjb25jdXJMaW07XG4gIHRoaXMuX2Ryb3AgPSBkcm9wO1xuICB0aGlzLl9xdWV1ZSA9IFtdO1xuICB0aGlzLl9jdXJTb3VyY2VzID0gW107XG4gIHRoaXMuXyRoYW5kbGVTdWJBbnkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gX3RoaXMuX2hhbmRsZVN1YkFueShldmVudCk7XG4gIH07XG4gIHRoaXMuXyRlbmRIYW5kbGVycyA9IFtdO1xuICB0aGlzLl9jdXJyZW50bHlBZGRpbmcgPSBudWxsO1xuXG4gIGlmICh0aGlzLl9jb25jdXJMaW0gPT09IDApIHtcbiAgICB0aGlzLl9lbWl0RW5kKCk7XG4gIH1cbn1cblxuaW5oZXJpdChBYnN0cmFjdFBvb2wsIFN0cmVhbSwge1xuICBfbmFtZTogJ2Fic3RyYWN0UG9vbCcsXG5cbiAgX2FkZDogZnVuY3Rpb24gKG9iaiwgdG9PYnMgLyogRnVuY3Rpb24gfCBmYWxzZXkgKi8pIHtcbiAgICB0b09icyA9IHRvT2JzIHx8IGlkJDg7XG4gICAgaWYgKHRoaXMuX2NvbmN1ckxpbSA9PT0gLTEgfHwgdGhpcy5fY3VyU291cmNlcy5sZW5ndGggPCB0aGlzLl9jb25jdXJMaW0pIHtcbiAgICAgIHRoaXMuX2FkZFRvQ3VyKHRvT2JzKG9iaikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fcXVldWVMaW0gPT09IC0xIHx8IHRoaXMuX3F1ZXVlLmxlbmd0aCA8IHRoaXMuX3F1ZXVlTGltKSB7XG4gICAgICAgIHRoaXMuX2FkZFRvUXVldWUodG9PYnMob2JqKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2Ryb3AgPT09ICdvbGQnKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZU9sZGVzdCgpO1xuICAgICAgICB0aGlzLl9hZGQob2JqLCB0b09icyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfYWRkQWxsOiBmdW5jdGlvbiAob2Jzcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgZm9yRWFjaChvYnNzLCBmdW5jdGlvbiAob2JzKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLl9hZGQob2JzKTtcbiAgICB9KTtcbiAgfSxcbiAgX3JlbW92ZTogZnVuY3Rpb24gKG9icykge1xuICAgIGlmICh0aGlzLl9yZW1vdmVDdXIob2JzKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX3JlbW92ZVF1ZXVlKG9icyk7XG4gICAgfVxuICB9LFxuICBfYWRkVG9RdWV1ZTogZnVuY3Rpb24gKG9icykge1xuICAgIHRoaXMuX3F1ZXVlID0gY29uY2F0KHRoaXMuX3F1ZXVlLCBbb2JzXSk7XG4gIH0sXG4gIF9hZGRUb0N1cjogZnVuY3Rpb24gKG9icykge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIC8vIEhBQ0s6XG4gICAgICAvL1xuICAgICAgLy8gV2UgaGF2ZSB0d28gb3B0aW1pemF0aW9ucyBmb3IgY2FzZXMgd2hlbiBgb2JzYCBpcyBlbmRlZC4gV2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gYWRkIHN1Y2ggb2JzZXJ2YWJsZSB0byB0aGUgbGlzdCwgYnV0IG9ubHkgd2FudCB0byBlbWl0IGV2ZW50c1xuICAgICAgLy8gZnJvbSBpdCAoaWYgaXQgaGFzIHNvbWUpLlxuICAgICAgLy9cbiAgICAgIC8vIEluc3RlYWQgb2YgdGhpcyBoYWNrcywgd2UgY291bGQganVzdCBkaWQgZm9sbG93aW5nLFxuICAgICAgLy8gYnV0IGl0IHdvdWxkIGJlIDUtOCB0aW1lcyBzbG93ZXI6XG4gICAgICAvL1xuICAgICAgLy8gICAgIHRoaXMuX2N1clNvdXJjZXMgPSBjb25jYXQodGhpcy5fY3VyU291cmNlcywgW29ic10pO1xuICAgICAgLy8gICAgIHRoaXMuX3N1YnNjcmliZShvYnMpO1xuICAgICAgLy9cblxuICAgICAgLy8gIzFcbiAgICAgIC8vIFRoaXMgb25lIGZvciBjYXNlcyB3aGVuIGBvYnNgIGFscmVhZHkgZW5kZWRcbiAgICAgIC8vIGUuZy4sIEtlZmlyLmNvbnN0YW50KCkgb3IgS2VmaXIubmV2ZXIoKVxuICAgICAgaWYgKCFvYnMuX2FsaXZlKSB7XG4gICAgICAgIGlmIChvYnMuX2N1cnJlbnRFdmVudCkge1xuICAgICAgICAgIHRoaXMuX2VtaXQob2JzLl9jdXJyZW50RXZlbnQudHlwZSwgb2JzLl9jdXJyZW50RXZlbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBfZW1pdCBhYm92ZSBjb3VsZCBoYXZlIGNhdXNlZCB0aGlzIHN0cmVhbSB0byBlbmQuXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wdWxsUXVldWUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2N1clNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVtcHR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gIzJcbiAgICAgIC8vIFRoaXMgb25lIGlzIGZvciBjYXNlcyB3aGVuIGBvYnNgIGdvaW5nIHRvIGVuZCBzeW5jaHJvbm91c2x5IG9uXG4gICAgICAvLyBmaXJzdCBzdWJzY3JpYmVyIGUuZy4sIEtlZmlyLnN0cmVhbShlbSA9PiB7ZW0uZW1pdCgxKTsgZW0uZW5kKCl9KVxuICAgICAgdGhpcy5fY3VycmVudGx5QWRkaW5nID0gb2JzO1xuICAgICAgb2JzLm9uQW55KHRoaXMuXyRoYW5kbGVTdWJBbnkpO1xuICAgICAgdGhpcy5fY3VycmVudGx5QWRkaW5nID0gbnVsbDtcbiAgICAgIGlmIChvYnMuX2FsaXZlKSB7XG4gICAgICAgIHRoaXMuX2N1clNvdXJjZXMgPSBjb25jYXQodGhpcy5fY3VyU291cmNlcywgW29ic10pO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy5fc3ViVG9FbmQob2JzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jdXJTb3VyY2VzID0gY29uY2F0KHRoaXMuX2N1clNvdXJjZXMsIFtvYnNdKTtcbiAgICB9XG4gIH0sXG4gIF9zdWJUb0VuZDogZnVuY3Rpb24gKG9icykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzMy5fcmVtb3ZlQ3VyKG9icyk7XG4gICAgfTtcbiAgICB0aGlzLl8kZW5kSGFuZGxlcnMucHVzaCh7IG9iczogb2JzLCBoYW5kbGVyOiBvbkVuZCB9KTtcbiAgICBvYnMub25FbmQob25FbmQpO1xuICB9LFxuICBfc3Vic2NyaWJlOiBmdW5jdGlvbiAob2JzKSB7XG4gICAgb2JzLm9uQW55KHRoaXMuXyRoYW5kbGVTdWJBbnkpO1xuXG4gICAgLy8gaXQgY2FuIGJlY29tZSBpbmFjdGl2ZSBpbiByZXNwb25jZSBvZiBzdWJzY3JpYmluZyB0byBgb2JzLm9uQW55YCBhYm92ZVxuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3N1YlRvRW5kKG9icyk7XG4gICAgfVxuICB9LFxuICBfdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIChvYnMpIHtcbiAgICBvYnMub2ZmQW55KHRoaXMuXyRoYW5kbGVTdWJBbnkpO1xuXG4gICAgdmFyIG9uRW5kSSA9IGZpbmRCeVByZWQodGhpcy5fJGVuZEhhbmRsZXJzLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLm9icyA9PT0gb2JzO1xuICAgIH0pO1xuICAgIGlmIChvbkVuZEkgIT09IC0xKSB7XG4gICAgICBvYnMub2ZmRW5kKHRoaXMuXyRlbmRIYW5kbGVyc1tvbkVuZEldLmhhbmRsZXIpO1xuICAgICAgdGhpcy5fJGVuZEhhbmRsZXJzLnNwbGljZShvbkVuZEksIDEpO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVN1YkFueTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFZBTFVFKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoZXZlbnQudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gRVJST1IpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihldmVudC52YWx1ZSk7XG4gICAgfVxuICB9LFxuICBfcmVtb3ZlUXVldWU6IGZ1bmN0aW9uIChvYnMpIHtcbiAgICB2YXIgaW5kZXggPSBmaW5kKHRoaXMuX3F1ZXVlLCBvYnMpO1xuICAgIHRoaXMuX3F1ZXVlID0gcmVtb3ZlKHRoaXMuX3F1ZXVlLCBpbmRleCk7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9LFxuICBfcmVtb3ZlQ3VyOiBmdW5jdGlvbiAob2JzKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fdW5zdWJzY3JpYmUob2JzKTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZCh0aGlzLl9jdXJTb3VyY2VzLCBvYnMpO1xuICAgIHRoaXMuX2N1clNvdXJjZXMgPSByZW1vdmUodGhpcy5fY3VyU291cmNlcywgaW5kZXgpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy5fcHVsbFF1ZXVlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2N1clNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX29uRW1wdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9LFxuICBfcmVtb3ZlT2xkZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ3VyKHRoaXMuX2N1clNvdXJjZXNbMF0pO1xuICB9LFxuICBfcHVsbFF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5fcXVldWUgPSBjbG9uZUFycmF5KHRoaXMuX3F1ZXVlKTtcbiAgICAgIHRoaXMuX2FkZFRvQ3VyKHRoaXMuX3F1ZXVlLnNoaWZ0KCkpO1xuICAgIH1cbiAgfSxcbiAgX29uQWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBzb3VyY2VzID0gdGhpcy5fY3VyU291cmNlczsgaSA8IHNvdXJjZXMubGVuZ3RoICYmIHRoaXMuX2FjdGl2ZTsgaSsrKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmUoc291cmNlc1tpXSk7XG4gICAgfVxuICB9LFxuICBfb25EZWFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgc291cmNlcyA9IHRoaXMuX2N1clNvdXJjZXM7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl91bnN1YnNjcmliZShzb3VyY2VzW2ldKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRseUFkZGluZyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fdW5zdWJzY3JpYmUodGhpcy5fY3VycmVudGx5QWRkaW5nKTtcbiAgICB9XG4gIH0sXG4gIF9pc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1clNvdXJjZXMubGVuZ3RoID09PSAwO1xuICB9LFxuICBfb25FbXB0eTogZnVuY3Rpb24gKCkge30sXG4gIF9jbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX2NsZWFyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcXVldWUgPSBudWxsO1xuICAgIHRoaXMuX2N1clNvdXJjZXMgPSBudWxsO1xuICAgIHRoaXMuXyRoYW5kbGVTdWJBbnkgPSBudWxsO1xuICAgIHRoaXMuXyRlbmRIYW5kbGVycyA9IG51bGw7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBNZXJnZShzb3VyY2VzKSB7XG4gIEFic3RyYWN0UG9vbC5jYWxsKHRoaXMpO1xuICB0aGlzLl9hZGRBbGwoc291cmNlcyk7XG4gIHRoaXMuX2luaXRpYWxpc2VkID0gdHJ1ZTtcbn1cblxuaW5oZXJpdChNZXJnZSwgQWJzdHJhY3RQb29sLCB7XG4gIF9uYW1lOiAnbWVyZ2UnLFxuXG4gIF9vbkVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpc2VkKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gbWVyZ2Uob2JzZXJ2YWJsZXMpIHtcbiAgcmV0dXJuIG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMCA/IG5ldmVyKCkgOiBuZXcgTWVyZ2Uob2JzZXJ2YWJsZXMpO1xufVxuXG5mdW5jdGlvbiBTJDMzKGdlbmVyYXRvcikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xuICB0aGlzLl9nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gIHRoaXMuX3NvdXJjZSA9IG51bGw7XG4gIHRoaXMuX2luTG9vcCA9IGZhbHNlO1xuICB0aGlzLl9pdGVyYXRpb24gPSAwO1xuICB0aGlzLl8kaGFuZGxlQW55ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIF90aGlzLl9oYW5kbGVBbnkoZXZlbnQpO1xuICB9O1xufVxuXG5pbmhlcml0KFMkMzMsIFN0cmVhbSwge1xuICBfbmFtZTogJ3JlcGVhdCcsXG5cbiAgX2hhbmRsZUFueTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IEVORCkge1xuICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMuX2dldFNvdXJjZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0KGV2ZW50LnR5cGUsIGV2ZW50LnZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIF9nZXRTb3VyY2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2luTG9vcCkge1xuICAgICAgdGhpcy5faW5Mb29wID0gdHJ1ZTtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSB0aGlzLl9nZW5lcmF0b3I7XG4gICAgICB3aGlsZSAodGhpcy5fc291cmNlID09PSBudWxsICYmIHRoaXMuX2FsaXZlICYmIHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBnZW5lcmF0b3IodGhpcy5faXRlcmF0aW9uKyspO1xuICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlLm9uQW55KHRoaXMuXyRoYW5kbGVBbnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW5Mb29wID0gZmFsc2U7XG4gICAgfVxuICB9LFxuICBfb25BY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuICAgICAgdGhpcy5fc291cmNlLm9uQW55KHRoaXMuXyRoYW5kbGVBbnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nZXRTb3VyY2UoKTtcbiAgICB9XG4gIH0sXG4gIF9vbkRlYWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgICAgIHRoaXMuX3NvdXJjZS5vZmZBbnkodGhpcy5fJGhhbmRsZUFueSk7XG4gICAgfVxuICB9LFxuICBfY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICBTdHJlYW0ucHJvdG90eXBlLl9jbGVhci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IG51bGw7XG4gICAgdGhpcy5fc291cmNlID0gbnVsbDtcbiAgICB0aGlzLl8kaGFuZGxlQW55ID0gbnVsbDtcbiAgfVxufSk7XG5cbnZhciByZXBlYXQgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yKSB7XG4gIHJldHVybiBuZXcgUyQzMyhnZW5lcmF0b3IpO1xufTtcblxuZnVuY3Rpb24gY29uY2F0JDEob2JzZXJ2YWJsZXMpIHtcbiAgcmV0dXJuIHJlcGVhdChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZXMubGVuZ3RoID4gaW5kZXggPyBvYnNlcnZhYmxlc1tpbmRleF0gOiBmYWxzZTtcbiAgfSkuc2V0TmFtZSgnY29uY2F0Jyk7XG59XG5cbmZ1bmN0aW9uIFBvb2woKSB7XG4gIEFic3RyYWN0UG9vbC5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0KFBvb2wsIEFic3RyYWN0UG9vbCwge1xuICBfbmFtZTogJ3Bvb2wnLFxuXG4gIHBsdWc6IGZ1bmN0aW9uIChvYnMpIHtcbiAgICB0aGlzLl9hZGQob2JzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdW5wbHVnOiBmdW5jdGlvbiAob2JzKSB7XG4gICAgdGhpcy5fcmVtb3ZlKG9icyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBGbGF0TWFwKHNvdXJjZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBBYnN0cmFjdFBvb2wuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICB0aGlzLl9mbiA9IGZuO1xuICB0aGlzLl9tYWluRW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5fbGFzdEN1cnJlbnQgPSBudWxsO1xuICB0aGlzLl8kaGFuZGxlTWFpbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBfdGhpcy5faGFuZGxlTWFpbihldmVudCk7XG4gIH07XG59XG5cbmluaGVyaXQoRmxhdE1hcCwgQWJzdHJhY3RQb29sLCB7XG4gIF9vbkFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICBBYnN0cmFjdFBvb2wucHJvdG90eXBlLl9vbkFjdGl2YXRpb24uY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9zb3VyY2Uub25BbnkodGhpcy5fJGhhbmRsZU1haW4pO1xuICAgIH1cbiAgfSxcbiAgX29uRGVhY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgQWJzdHJhY3RQb29sLnByb3RvdHlwZS5fb25EZWFjdGl2YXRpb24uY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2Uub2ZmQW55KHRoaXMuXyRoYW5kbGVNYWluKTtcbiAgICB0aGlzLl9oYWROb0V2U2luY2VEZWFjdCA9IHRydWU7XG4gIH0sXG4gIF9oYW5kbGVNYWluOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gVkFMVUUpIHtcbiAgICAgIC8vIElzIGxhdGVzdCB2YWx1ZSBiZWZvcmUgZGVhY3RpdmF0aW9uIHN1cnZpdmVkLCBhbmQgbm93IGlzICdjdXJyZW50JyBvbiB0aGlzIGFjdGl2YXRpb24/XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGhhbmRsZSBzdWNoIHZhbHVlcywgdG8gcHJldmVudCB0byBjb25zdGFudGx5IGFkZFxuICAgICAgLy8gc2FtZSBvYnNlcnZhbGUgb24gZWFjaCBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbiB3aGVuIG91ciBtYWluIHNvdXJjZVxuICAgICAgLy8gaXMgYSBgS2VmaXIuY29uYXRhbnQoKWAgZm9yIGV4YW1wbGUuXG4gICAgICB2YXIgc2FtZUN1cnIgPSB0aGlzLl9hY3RpdmF0aW5nICYmIHRoaXMuX2hhZE5vRXZTaW5jZURlYWN0ICYmIHRoaXMuX2xhc3RDdXJyZW50ID09PSBldmVudC52YWx1ZTtcbiAgICAgIGlmICghc2FtZUN1cnIpIHtcbiAgICAgICAgdGhpcy5fYWRkKGV2ZW50LnZhbHVlLCB0aGlzLl9mbik7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXN0Q3VycmVudCA9IGV2ZW50LnZhbHVlO1xuICAgICAgdGhpcy5faGFkTm9FdlNpbmNlRGVhY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gRVJST1IpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihldmVudC52YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IEVORCkge1xuICAgICAgaWYgKHRoaXMuX2lzRW1wdHkoKSkge1xuICAgICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tYWluRW5kZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX29uRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fbWFpbkVuZGVkKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9LFxuICBfY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICBBYnN0cmFjdFBvb2wucHJvdG90eXBlLl9jbGVhci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fbGFzdEN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuXyRoYW5kbGVNYWluID0gbnVsbDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIEZsYXRNYXBFcnJvcnMoc291cmNlLCBmbikge1xuICBGbGF0TWFwLmNhbGwodGhpcywgc291cmNlLCBmbik7XG59XG5cbmluaGVyaXQoRmxhdE1hcEVycm9ycywgRmxhdE1hcCwge1xuICAvLyBTYW1lIGFzIGluIEZsYXRNYXAsIG9ubHkgVkFMVUUvRVJST1IgZmxpcHBlZFxuICBfaGFuZGxlTWFpbjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IEVSUk9SKSB7XG4gICAgICB2YXIgc2FtZUN1cnIgPSB0aGlzLl9hY3RpdmF0aW5nICYmIHRoaXMuX2hhZE5vRXZTaW5jZURlYWN0ICYmIHRoaXMuX2xhc3RDdXJyZW50ID09PSBldmVudC52YWx1ZTtcbiAgICAgIGlmICghc2FtZUN1cnIpIHtcbiAgICAgICAgdGhpcy5fYWRkKGV2ZW50LnZhbHVlLCB0aGlzLl9mbik7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXN0Q3VycmVudCA9IGV2ZW50LnZhbHVlO1xuICAgICAgdGhpcy5faGFkTm9FdlNpbmNlRGVhY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gVkFMVUUpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZShldmVudC52YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IEVORCkge1xuICAgICAgaWYgKHRoaXMuX2lzRW1wdHkoKSkge1xuICAgICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tYWluRW5kZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnN0cnVjdG9yJDEoQmFzZUNsYXNzLCBuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBBbm9ueW1vdXNPYnNlcnZhYmxlKHByaW1hcnksIHNlY29uZGFyeSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBCYXNlQ2xhc3MuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9wcmltYXJ5ID0gcHJpbWFyeTtcbiAgICB0aGlzLl9zZWNvbmRhcnkgPSBzZWNvbmRhcnk7XG4gICAgdGhpcy5fbmFtZSA9IHByaW1hcnkuX25hbWUgKyAnLicgKyBuYW1lO1xuICAgIHRoaXMuX2xhc3RTZWNvbmRhcnkgPSBOT1RISU5HO1xuICAgIHRoaXMuXyRoYW5kbGVTZWNvbmRhcnlBbnkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5faGFuZGxlU2Vjb25kYXJ5QW55KGV2ZW50KTtcbiAgICB9O1xuICAgIHRoaXMuXyRoYW5kbGVQcmltYXJ5QW55ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZVByaW1hcnlBbnkoZXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NNZXRob2RzJDEoQmFzZUNsYXNzKSB7XG4gIHJldHVybiB7XG4gICAgX2luaXQ6IGZ1bmN0aW9uICgpIHt9LFxuICAgIF9mcmVlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICBfaGFuZGxlUHJpbWFyeVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH0sXG4gICAgX2hhbmRsZVByaW1hcnlFcnJvcjogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcih4KTtcbiAgICB9LFxuICAgIF9oYW5kbGVQcmltYXJ5RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfSxcbiAgICBfaGFuZGxlU2Vjb25kYXJ5VmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9sYXN0U2Vjb25kYXJ5ID0geDtcbiAgICB9LFxuICAgIF9oYW5kbGVTZWNvbmRhcnlFcnJvcjogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcih4KTtcbiAgICB9LFxuICAgIF9oYW5kbGVTZWNvbmRhcnlFbmQ6IGZ1bmN0aW9uICgpIHt9LFxuICAgIF9oYW5kbGVQcmltYXJ5QW55OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFZBTFVFOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVQcmltYXJ5VmFsdWUoZXZlbnQudmFsdWUpO1xuICAgICAgICBjYXNlIEVSUk9SOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVQcmltYXJ5RXJyb3IoZXZlbnQudmFsdWUpO1xuICAgICAgICBjYXNlIEVORDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlUHJpbWFyeUVuZChldmVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfaGFuZGxlU2Vjb25kYXJ5QW55OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFZBTFVFOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVTZWNvbmRhcnlWYWx1ZShldmVudC52YWx1ZSk7XG4gICAgICAgIGNhc2UgRVJST1I6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVNlY29uZGFyeUVycm9yKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgY2FzZSBFTkQ6XG4gICAgICAgICAgdGhpcy5faGFuZGxlU2Vjb25kYXJ5RW5kKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVTZWNvbmRhcnkoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9yZW1vdmVTZWNvbmRhcnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9zZWNvbmRhcnkgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5Lm9mZkFueSh0aGlzLl8kaGFuZGxlU2Vjb25kYXJ5QW55KTtcbiAgICAgICAgdGhpcy5fJGhhbmRsZVNlY29uZGFyeUFueSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NlY29uZGFyeSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBfb25BY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fc2Vjb25kYXJ5ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NlY29uZGFyeS5vbkFueSh0aGlzLl8kaGFuZGxlU2Vjb25kYXJ5QW55KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fcHJpbWFyeS5vbkFueSh0aGlzLl8kaGFuZGxlUHJpbWFyeUFueSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfb25EZWFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9zZWNvbmRhcnkgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5Lm9mZkFueSh0aGlzLl8kaGFuZGxlU2Vjb25kYXJ5QW55KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ByaW1hcnkub2ZmQW55KHRoaXMuXyRoYW5kbGVQcmltYXJ5QW55KTtcbiAgICB9LFxuICAgIF9jbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgQmFzZUNsYXNzLnByb3RvdHlwZS5fY2xlYXIuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuX3ByaW1hcnkgPSBudWxsO1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5ID0gbnVsbDtcbiAgICAgIHRoaXMuX2xhc3RTZWNvbmRhcnkgPSBudWxsO1xuICAgICAgdGhpcy5fJGhhbmRsZVNlY29uZGFyeUFueSA9IG51bGw7XG4gICAgICB0aGlzLl8kaGFuZGxlUHJpbWFyeUFueSA9IG51bGw7XG4gICAgICB0aGlzLl9mcmVlKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW0kMShuYW1lLCBtaXhpbikge1xuICB2YXIgUyA9IGNyZWF0ZUNvbnN0cnVjdG9yJDEoU3RyZWFtLCBuYW1lKTtcbiAgaW5oZXJpdChTLCBTdHJlYW0sIGNyZWF0ZUNsYXNzTWV0aG9kcyQxKFN0cmVhbSksIG1peGluKTtcbiAgcmV0dXJuIFM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5JDEobmFtZSwgbWl4aW4pIHtcbiAgdmFyIFAgPSBjcmVhdGVDb25zdHJ1Y3RvciQxKFByb3BlcnR5LCBuYW1lKTtcbiAgaW5oZXJpdChQLCBQcm9wZXJ0eSwgY3JlYXRlQ2xhc3NNZXRob2RzJDEoUHJvcGVydHkpLCBtaXhpbik7XG4gIHJldHVybiBQO1xufVxuXG52YXIgbWl4aW4kMjYgPSB7XG4gIF9oYW5kbGVQcmltYXJ5VmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHRoaXMuX2xhc3RTZWNvbmRhcnkgIT09IE5PVEhJTkcgJiYgdGhpcy5fbGFzdFNlY29uZGFyeSkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVNlY29uZGFyeUVuZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9sYXN0U2Vjb25kYXJ5ID09PSBOT1RISU5HIHx8ICF0aGlzLl9sYXN0U2Vjb25kYXJ5KSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQzNCA9IGNyZWF0ZVN0cmVhbSQxKCdmaWx0ZXJCeScsIG1peGluJDI2KTtcbnZhciBQJDI5ID0gY3JlYXRlUHJvcGVydHkkMSgnZmlsdGVyQnknLCBtaXhpbiQyNik7XG5cbmZ1bmN0aW9uIGZpbHRlckJ5KHByaW1hcnksIHNlY29uZGFyeSkge1xuICByZXR1cm4gbmV3IChwcmltYXJ5Ll9vZlNhbWVUeXBlKFMkMzQsIFAkMjkpKShwcmltYXJ5LCBzZWNvbmRhcnkpO1xufVxuXG52YXIgaWQyID0gZnVuY3Rpb24gKF8sIHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG5mdW5jdGlvbiBzYW1wbGVkQnkocGFzc2l2ZSwgYWN0aXZlLCBjb21iaW5hdG9yKSB7XG4gIHZhciBfY29tYmluYXRvciA9IGNvbWJpbmF0b3IgPyBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBjb21iaW5hdG9yKGIsIGEpO1xuICB9IDogaWQyO1xuICByZXR1cm4gY29tYmluZShbYWN0aXZlXSwgW3Bhc3NpdmVdLCBfY29tYmluYXRvcikuc2V0TmFtZShwYXNzaXZlLCAnc2FtcGxlZEJ5Jyk7XG59XG5cbnZhciBtaXhpbiQyNyA9IHtcbiAgX2hhbmRsZVByaW1hcnlWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fbGFzdFNlY29uZGFyeSAhPT0gTk9USElORykge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVNlY29uZGFyeUVuZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9sYXN0U2Vjb25kYXJ5ID09PSBOT1RISU5HKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQzNSA9IGNyZWF0ZVN0cmVhbSQxKCdza2lwVW50aWxCeScsIG1peGluJDI3KTtcbnZhciBQJDMwID0gY3JlYXRlUHJvcGVydHkkMSgnc2tpcFVudGlsQnknLCBtaXhpbiQyNyk7XG5cbmZ1bmN0aW9uIHNraXBVbnRpbEJ5KHByaW1hcnksIHNlY29uZGFyeSkge1xuICByZXR1cm4gbmV3IChwcmltYXJ5Ll9vZlNhbWVUeXBlKFMkMzUsIFAkMzApKShwcmltYXJ5LCBzZWNvbmRhcnkpO1xufVxuXG52YXIgbWl4aW4kMjggPSB7XG4gIF9oYW5kbGVTZWNvbmRhcnlWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgfVxufTtcblxudmFyIFMkMzYgPSBjcmVhdGVTdHJlYW0kMSgndGFrZVVudGlsQnknLCBtaXhpbiQyOCk7XG52YXIgUCQzMSA9IGNyZWF0ZVByb3BlcnR5JDEoJ3Rha2VVbnRpbEJ5JywgbWl4aW4kMjgpO1xuXG5mdW5jdGlvbiB0YWtlVW50aWxCeShwcmltYXJ5LCBzZWNvbmRhcnkpIHtcbiAgcmV0dXJuIG5ldyAocHJpbWFyeS5fb2ZTYW1lVHlwZShTJDM2LCBQJDMxKSkocHJpbWFyeSwgc2Vjb25kYXJ5KTtcbn1cblxudmFyIG1peGluJDI5ID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZiRmbHVzaE9uRW5kID0gX3JlZi5mbHVzaE9uRW5kLFxuICAgICAgICBmbHVzaE9uRW5kID0gX3JlZiRmbHVzaE9uRW5kID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZiRmbHVzaE9uRW5kO1xuXG4gICAgdGhpcy5fYnVmZiA9IFtdO1xuICAgIHRoaXMuX2ZsdXNoT25FbmQgPSBmbHVzaE9uRW5kO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2J1ZmYgPSBudWxsO1xuICB9LFxuICBfZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fYnVmZiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHRoaXMuX2J1ZmYpO1xuICAgICAgdGhpcy5fYnVmZiA9IFtdO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVByaW1hcnlFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmx1c2hPbkVuZCkge1xuICAgICAgdGhpcy5fZmx1c2goKTtcbiAgICB9XG4gICAgdGhpcy5fZW1pdEVuZCgpO1xuICB9LFxuICBfb25BY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcHJpbWFyeS5vbkFueSh0aGlzLl8kaGFuZGxlUHJpbWFyeUFueSk7XG4gICAgaWYgKHRoaXMuX2FsaXZlICYmIHRoaXMuX3NlY29uZGFyeSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5Lm9uQW55KHRoaXMuXyRoYW5kbGVTZWNvbmRhcnlBbnkpO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVByaW1hcnlWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICB0aGlzLl9idWZmLnB1c2goeCk7XG4gIH0sXG4gIF9oYW5kbGVTZWNvbmRhcnlWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZsdXNoKCk7XG4gIH0sXG4gIF9oYW5kbGVTZWNvbmRhcnlFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2ZsdXNoT25FbmQpIHtcbiAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBTJDM3ID0gY3JlYXRlU3RyZWFtJDEoJ2J1ZmZlckJ5JywgbWl4aW4kMjkpO1xudmFyIFAkMzIgPSBjcmVhdGVQcm9wZXJ0eSQxKCdidWZmZXJCeScsIG1peGluJDI5KTtcblxuZnVuY3Rpb24gYnVmZmVyQnkocHJpbWFyeSwgc2Vjb25kYXJ5LCBvcHRpb25zIC8qIG9wdGlvbmFsICovKSB7XG4gIHJldHVybiBuZXcgKHByaW1hcnkuX29mU2FtZVR5cGUoUyQzNywgUCQzMikpKHByaW1hcnksIHNlY29uZGFyeSwgb3B0aW9ucyk7XG59XG5cbnZhciBtaXhpbiQzMCA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYkZmx1c2hPbkVuZCA9IF9yZWYuZmx1c2hPbkVuZCxcbiAgICAgICAgZmx1c2hPbkVuZCA9IF9yZWYkZmx1c2hPbkVuZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkZmx1c2hPbkVuZCxcbiAgICAgICAgX3JlZiRmbHVzaE9uQ2hhbmdlID0gX3JlZi5mbHVzaE9uQ2hhbmdlLFxuICAgICAgICBmbHVzaE9uQ2hhbmdlID0gX3JlZiRmbHVzaE9uQ2hhbmdlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkZmx1c2hPbkNoYW5nZTtcblxuICAgIHRoaXMuX2J1ZmYgPSBbXTtcbiAgICB0aGlzLl9mbHVzaE9uRW5kID0gZmx1c2hPbkVuZDtcbiAgICB0aGlzLl9mbHVzaE9uQ2hhbmdlID0gZmx1c2hPbkNoYW5nZTtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9idWZmID0gbnVsbDtcbiAgfSxcbiAgX2ZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmYgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh0aGlzLl9idWZmKTtcbiAgICAgIHRoaXMuX2J1ZmYgPSBbXTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVQcmltYXJ5RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2ZsdXNoT25FbmQpIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgfSxcbiAgX2hhbmRsZVByaW1hcnlWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICB0aGlzLl9idWZmLnB1c2goeCk7XG4gICAgaWYgKHRoaXMuX2xhc3RTZWNvbmRhcnkgIT09IE5PVEhJTkcgJiYgIXRoaXMuX2xhc3RTZWNvbmRhcnkpIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlU2Vjb25kYXJ5RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9mbHVzaE9uRW5kICYmICh0aGlzLl9sYXN0U2Vjb25kYXJ5ID09PSBOT1RISU5HIHx8IHRoaXMuX2xhc3RTZWNvbmRhcnkpKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlU2Vjb25kYXJ5VmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHRoaXMuX2ZsdXNoT25DaGFuZ2UgJiYgIXgpIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuXG4gICAgLy8gZnJvbSBkZWZhdWx0IF9oYW5kbGVTZWNvbmRhcnlWYWx1ZVxuICAgIHRoaXMuX2xhc3RTZWNvbmRhcnkgPSB4O1xuICB9XG59O1xuXG52YXIgUyQzOCA9IGNyZWF0ZVN0cmVhbSQxKCdidWZmZXJXaGlsZUJ5JywgbWl4aW4kMzApO1xudmFyIFAkMzMgPSBjcmVhdGVQcm9wZXJ0eSQxKCdidWZmZXJXaGlsZUJ5JywgbWl4aW4kMzApO1xuXG5mdW5jdGlvbiBidWZmZXJXaGlsZUJ5KHByaW1hcnksIHNlY29uZGFyeSwgb3B0aW9ucyAvKiBvcHRpb25hbCAqLykge1xuICByZXR1cm4gbmV3IChwcmltYXJ5Ll9vZlNhbWVUeXBlKFMkMzgsIFAkMzMpKShwcmltYXJ5LCBzZWNvbmRhcnksIG9wdGlvbnMpO1xufVxuXG52YXIgZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciB0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGF3YWl0aW5nKGEsIGIpIHtcbiAgdmFyIHJlc3VsdCA9IG1lcmdlKFttYXAkMShhLCB0KSwgbWFwJDEoYiwgZildKTtcbiAgcmVzdWx0ID0gc2tpcER1cGxpY2F0ZXMocmVzdWx0KTtcbiAgcmVzdWx0ID0gdG9Qcm9wZXJ0eShyZXN1bHQsIGYpO1xuICByZXR1cm4gcmVzdWx0LnNldE5hbWUoYSwgJ2F3YWl0aW5nJyk7XG59XG5cbnZhciBtaXhpbiQzMSA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGZuID0gX3JlZi5mbjtcblxuICAgIHRoaXMuX2ZuID0gZm47XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZm4gPSBudWxsO1xuICB9LFxuICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIGZuID0gdGhpcy5fZm47XG4gICAgdmFyIHJlc3VsdCA9IGZuKHgpO1xuICAgIGlmIChyZXN1bHQuY29udmVydCkge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKHJlc3VsdC5lcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh4KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBTJDM5ID0gY3JlYXRlU3RyZWFtKCd2YWx1ZXNUb0Vycm9ycycsIG1peGluJDMxKTtcbnZhciBQJDM0ID0gY3JlYXRlUHJvcGVydHkoJ3ZhbHVlc1RvRXJyb3JzJywgbWl4aW4kMzEpO1xuXG52YXIgZGVmRm4gPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geyBjb252ZXJ0OiB0cnVlLCBlcnJvcjogeCB9O1xufTtcblxuZnVuY3Rpb24gdmFsdWVzVG9FcnJvcnMob2JzKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZGVmRm47XG5cbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMzksIFAkMzQpKShvYnMsIHsgZm46IGZuIH0pO1xufVxuXG52YXIgbWl4aW4kMzIgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZUVycm9yOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIHZhciByZXN1bHQgPSBmbih4KTtcbiAgICBpZiAocmVzdWx0LmNvbnZlcnQpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZShyZXN1bHQudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0RXJyb3IoeCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQ0MCA9IGNyZWF0ZVN0cmVhbSgnZXJyb3JzVG9WYWx1ZXMnLCBtaXhpbiQzMik7XG52YXIgUCQzNSA9IGNyZWF0ZVByb3BlcnR5KCdlcnJvcnNUb1ZhbHVlcycsIG1peGluJDMyKTtcblxudmFyIGRlZkZuJDEgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geyBjb252ZXJ0OiB0cnVlLCB2YWx1ZTogeCB9O1xufTtcblxuZnVuY3Rpb24gZXJyb3JzVG9WYWx1ZXMob2JzKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZGVmRm4kMTtcblxuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQ0MCwgUCQzNSkpKG9icywgeyBmbjogZm4gfSk7XG59XG5cbnZhciBtaXhpbiQzMyA9IHtcbiAgX2hhbmRsZUVycm9yOiBmdW5jdGlvbiAoeCkge1xuICAgIHRoaXMuX2VtaXRFcnJvcih4KTtcbiAgICB0aGlzLl9lbWl0RW5kKCk7XG4gIH1cbn07XG5cbnZhciBTJDQxID0gY3JlYXRlU3RyZWFtKCdlbmRPbkVycm9yJywgbWl4aW4kMzMpO1xudmFyIFAkMzYgPSBjcmVhdGVQcm9wZXJ0eSgnZW5kT25FcnJvcicsIG1peGluJDMzKTtcblxuZnVuY3Rpb24gZW5kT25FcnJvcihvYnMpIHtcbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkNDEsIFAkMzYpKShvYnMpO1xufVxuXG4vLyBDcmVhdGUgYSBzdHJlYW1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vICgpIC0+IFN0cmVhbVxuLy8gKG51bWJlciwgYW55KSAtPiBTdHJlYW1cbi8vIChudW1iZXIsIGFueSkgLT4gU3RyZWFtXG4vLyAobnVtYmVyLCBBcnJheTxhbnk+KSAtPiBTdHJlYW1cbi8vIChudW1iZXIsIEZ1bmN0aW9uKSAtPiBTdHJlYW1cbi8vIChudW1iZXIsIEZ1bmN0aW9uKSAtPiBTdHJlYW1cbi8vIChGdW5jdGlvbikgLT4gU3RyZWFtXG4vLyAoRnVuY3Rpb24pIC0+IFN0cmVhbVxuLy8gVGFyZ2V0ID0ge2FkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXJ9fHthZGRMaXN0ZW5lciwgcmVtb3ZlTGlzdGVuZXJ9fHtvbiwgb2ZmfVxuLy8gKFRhcmdldCwgc3RyaW5nLCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKEZ1bmN0aW9uKSAtPiBTdHJlYW1cbi8vIENyZWF0ZSBhIHByb3BlcnR5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyAoYW55KSAtPiBQcm9wZXJ0eVxuLy8gKGFueSkgLT4gUHJvcGVydHlcbi8vIENvbnZlcnQgb2JzZXJ2YWJsZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIChTdHJlYW18UHJvcGVydHksIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnRvUHJvcGVydHkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIHRvUHJvcGVydHkodGhpcywgZm4pO1xufTtcblxuLy8gKFN0cmVhbXxQcm9wZXJ0eSkgLT4gU3RyZWFtXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5jaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2hhbmdlcyh0aGlzKTtcbn07XG5cbi8vIEludGVyb3BlcmF0aW9uIHdpdGggb3RoZXIgaW1wbGltZW50YXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyAoUHJvbWlzZSkgLT4gUHJvcGVydHlcbi8vIChTdHJlYW18UHJvcGVydHksIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gUHJvbWlzZVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9Qcm9taXNlID0gZnVuY3Rpb24gKFByb21pc2UpIHtcbiAgcmV0dXJuIHRvUHJvbWlzZSh0aGlzLCBQcm9taXNlKTtcbn07XG5cbi8vIChFU09ic2VydmFibGUpIC0+IFN0cmVhbVxuLy8gKFN0cmVhbXxQcm9wZXJ0eSkgLT4gRVM3IE9ic2VydmFibGVcbk9ic2VydmFibGUucHJvdG90eXBlLnRvRVNPYnNlcnZhYmxlID0gdG9FU09ic2VydmFibGU7XG5PYnNlcnZhYmxlLnByb3RvdHlwZVskJG9ic2VydmFibGVdID0gdG9FU09ic2VydmFibGU7XG5cbi8vIE1vZGlmeSBhbiBvYnNlcnZhYmxlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyAoU3RyZWFtLCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIG1hcCQxKHRoaXMsIGZuKTtcbn07XG5cbi8vIChTdHJlYW0sIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZmlsdGVyKHRoaXMsIGZuKTtcbn07XG5cbi8vIChTdHJlYW0sIG51bWJlcikgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIG51bWJlcikgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnRha2UgPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gdGFrZSh0aGlzLCBuKTtcbn07XG5cbi8vIChTdHJlYW0sIG51bWJlcikgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIG51bWJlcikgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnRha2VFcnJvcnMgPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gdGFrZUVycm9ycyh0aGlzLCBuKTtcbn07XG5cbi8vIChTdHJlYW0sIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnRha2VXaGlsZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gdGFrZVdoaWxlKHRoaXMsIGZuKTtcbn07XG5cbi8vIChTdHJlYW0pIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5KSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGxhc3QodGhpcyk7XG59O1xuXG4vLyAoU3RyZWFtLCBudW1iZXIpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBudW1iZXIpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIHNraXAodGhpcywgbik7XG59O1xuXG4vLyAoU3RyZWFtLCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwV2hpbGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIHNraXBXaGlsZSh0aGlzLCBmbik7XG59O1xuXG4vLyAoU3RyZWFtLCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwRHVwbGljYXRlcyA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gc2tpcER1cGxpY2F0ZXModGhpcywgZm4pO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb258ZmFsc2V5LCBhbnl8dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgRnVuY3Rpb258ZmFsc2V5LCBhbnl8dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChmbiwgc2VlZCkge1xuICByZXR1cm4gZGlmZih0aGlzLCBmbiwgc2VlZCk7XG59O1xuXG4vLyAoU3RyZWFtfFByb3BlcnR5LCBGdW5jdGlvbiwgYW55fHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnNjYW4gPSBmdW5jdGlvbiAoZm4sIHNlZWQpIHtcbiAgcmV0dXJuIHNjYW4odGhpcywgZm4sIHNlZWQpO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZmxhdHRlbih0aGlzLCBmbik7XG59O1xuXG4vLyAoU3RyZWFtLCBudW1iZXIpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBudW1iZXIpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh3YWl0KSB7XG4gIHJldHVybiBkZWxheSh0aGlzLCB3YWl0KTtcbn07XG5cbi8vIE9wdGlvbnMgPSB7bGVhZGluZzogYm9vbGVhbnx1bmRlZmluZWQsIHRyYWlsaW5nOiBib29sZWFufHVuZGVmaW5lZH1cbi8vIChTdHJlYW0sIG51bWJlciwgT3B0aW9uc3x1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBudW1iZXIsIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGhyb3R0bGUgPSBmdW5jdGlvbiAod2FpdCwgb3B0aW9ucykge1xuICByZXR1cm4gdGhyb3R0bGUodGhpcywgd2FpdCwgb3B0aW9ucyk7XG59O1xuXG4vLyBPcHRpb25zID0ge2ltbWVkaWF0ZTogYm9vbGVhbnx1bmRlZmluZWR9XG4vLyAoU3RyZWFtLCBudW1iZXIsIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgbnVtYmVyLCBPcHRpb25zfHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmRlYm91bmNlID0gZnVuY3Rpb24gKHdhaXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRlYm91bmNlKHRoaXMsIHdhaXQsIG9wdGlvbnMpO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWFwRXJyb3JzID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBtYXBFcnJvcnModGhpcywgZm4pO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmlsdGVyRXJyb3JzID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmaWx0ZXJFcnJvcnModGhpcywgZm4pO1xufTtcblxuLy8gKFN0cmVhbSkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHkpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5pZ25vcmVWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpZ25vcmVWYWx1ZXModGhpcyk7XG59O1xuXG4vLyAoU3RyZWFtKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmlnbm9yZUVycm9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlnbm9yZUVycm9ycyh0aGlzKTtcbn07XG5cbi8vIChTdHJlYW0pIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5KSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuaWdub3JlRW5kID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaWdub3JlRW5kKHRoaXMpO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb24pIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbikgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmJlZm9yZUVuZCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gYmVmb3JlRW5kKHRoaXMsIGZuKTtcbn07XG5cbi8vIChTdHJlYW0sIG51bWJlciwgbnVtYmVyfHVuZGVmaW5lZCkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIG51bWJlciwgbnVtYmVyfHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnNsaWRpbmdXaW5kb3cgPSBmdW5jdGlvbiAobWF4LCBtaW4pIHtcbiAgcmV0dXJuIHNsaWRpbmdXaW5kb3codGhpcywgbWF4LCBtaW4pO1xufTtcblxuLy8gT3B0aW9ucyA9IHtmbHVzaE9uRW5kOiBib29sZWFufHVuZGVmaW5lZH1cbi8vIChTdHJlYW0sIEZ1bmN0aW9ufGZhbHNleSwgT3B0aW9uc3x1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbnxmYWxzZXksIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyV2hpbGUgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJ1ZmZlcldoaWxlKHRoaXMsIGZuLCBvcHRpb25zKTtcbn07XG5cbi8vIChTdHJlYW0sIG51bWJlcikgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIG51bWJlcikgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlcldpdGhDb3VudCA9IGZ1bmN0aW9uIChjb3VudCwgb3B0aW9ucykge1xuICByZXR1cm4gYnVmZmVyV2hpbGUkMSh0aGlzLCBjb3VudCwgb3B0aW9ucyk7XG59O1xuXG4vLyBPcHRpb25zID0ge2ZsdXNoT25FbmQ6IGJvb2xlYW58dW5kZWZpbmVkfVxuLy8gKFN0cmVhbSwgbnVtYmVyLCBudW1iZXIsIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgbnVtYmVyLCBudW1iZXIsIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyV2l0aFRpbWVPckNvdW50ID0gZnVuY3Rpb24gKHdhaXQsIGNvdW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBidWZmZXJXaXRoVGltZU9yQ291bnQodGhpcywgd2FpdCwgY291bnQsIG9wdGlvbnMpO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb24pIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbikgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnRyYW5zZHVjZSA9IGZ1bmN0aW9uICh0cmFuc2R1Y2VyKSB7XG4gIHJldHVybiB0cmFuc2R1Y2UodGhpcywgdHJhbnNkdWNlcik7XG59O1xuXG4vLyAoU3RyZWFtLCBGdW5jdGlvbikgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIEZ1bmN0aW9uKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2l0aEhhbmRsZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIHdpdGhIYW5kbGVyKHRoaXMsIGZuKTtcbn07XG5cbi8vIChTdHJlYW0sIFN0cmVhbSAtPiBhKSAtPiBhXG4vLyAoUHJvcGVydHksIFByb3BlcnR5IC0+IGEpIC0+IGFcbk9ic2VydmFibGUucHJvdG90eXBlLnRocnUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuKHRoaXMpO1xufTtcblxuLy8gQ29tYmluZSBvYnNlcnZhYmxlc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gKEFycmF5PFN0cmVhbXxQcm9wZXJ0eT4sIEZ1bmN0aW9ufHVuZGVmaWVuZCkgLT4gU3RyZWFtXG4vLyAoQXJyYXk8U3RyZWFtfFByb3BlcnR5PiwgQXJyYXk8U3RyZWFtfFByb3BlcnR5PiwgRnVuY3Rpb258dW5kZWZpZW5kKSAtPiBTdHJlYW1cbk9ic2VydmFibGUucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbiAob3RoZXIsIGNvbWJpbmF0b3IpIHtcbiAgcmV0dXJuIGNvbWJpbmUoW3RoaXMsIG90aGVyXSwgY29tYmluYXRvcik7XG59O1xuXG4vLyAoQXJyYXk8U3RyZWFtfFByb3BlcnR5PiwgRnVuY3Rpb258dW5kZWZpZW5kKSAtPiBTdHJlYW1cbk9ic2VydmFibGUucHJvdG90eXBlLnppcCA9IGZ1bmN0aW9uIChvdGhlciwgY29tYmluYXRvcikge1xuICByZXR1cm4gemlwKFt0aGlzLCBvdGhlcl0sIGNvbWJpbmF0b3IpO1xufTtcblxuLy8gKEFycmF5PFN0cmVhbXxQcm9wZXJ0eT4pIC0+IFN0cmVhbVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgcmV0dXJuIG1lcmdlKFt0aGlzLCBvdGhlcl0pO1xufTtcblxuLy8gKEFycmF5PFN0cmVhbXxQcm9wZXJ0eT4pIC0+IFN0cmVhbVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHJldHVybiBjb25jYXQkMShbdGhpcywgb3RoZXJdKTtcbn07XG5cbi8vICgpIC0+IFBvb2xcbnZhciBwb29sID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvb2woKTtcbn07XG5cbi8vIChGdW5jdGlvbikgLT4gU3RyZWFtXG4vLyBPcHRpb25zID0ge2NvbmN1ckxpbTogbnVtYmVyfHVuZGVmaW5lZCwgcXVldWVMaW06IG51bWJlcnx1bmRlZmluZWQsIGRyb3A6ICdvbGQnfCduZXcnfHVuZGVmaWVuZH1cbi8vIChTdHJlYW18UHJvcGVydHksIEZ1bmN0aW9ufGZhbHNleSwgT3B0aW9uc3x1bmRlZmluZWQpIC0+IFN0cmVhbVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmxhdE1hcCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gbmV3IEZsYXRNYXAodGhpcywgZm4pLnNldE5hbWUodGhpcywgJ2ZsYXRNYXAnKTtcbn07XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5mbGF0TWFwTGF0ZXN0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBuZXcgRmxhdE1hcCh0aGlzLCBmbiwgeyBjb25jdXJMaW06IDEsIGRyb3A6ICdvbGQnIH0pLnNldE5hbWUodGhpcywgJ2ZsYXRNYXBMYXRlc3QnKTtcbn07XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5mbGF0TWFwRmlyc3QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIG5ldyBGbGF0TWFwKHRoaXMsIGZuLCB7IGNvbmN1ckxpbTogMSB9KS5zZXROYW1lKHRoaXMsICdmbGF0TWFwRmlyc3QnKTtcbn07XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5mbGF0TWFwQ29uY2F0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBuZXcgRmxhdE1hcCh0aGlzLCBmbiwgeyBxdWV1ZUxpbTogLTEsIGNvbmN1ckxpbTogMSB9KS5zZXROYW1lKHRoaXMsICdmbGF0TWFwQ29uY2F0Jyk7XG59O1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmxhdE1hcENvbmN1ckxpbWl0ID0gZnVuY3Rpb24gKGZuLCBsaW1pdCkge1xuICByZXR1cm4gbmV3IEZsYXRNYXAodGhpcywgZm4sIHsgcXVldWVMaW06IC0xLCBjb25jdXJMaW06IGxpbWl0IH0pLnNldE5hbWUodGhpcywgJ2ZsYXRNYXBDb25jdXJMaW1pdCcpO1xufTtcblxuLy8gKFN0cmVhbXxQcm9wZXJ0eSwgRnVuY3Rpb258ZmFsc2V5KSAtPiBTdHJlYW1cbk9ic2VydmFibGUucHJvdG90eXBlLmZsYXRNYXBFcnJvcnMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIG5ldyBGbGF0TWFwRXJyb3JzKHRoaXMsIGZuKS5zZXROYW1lKHRoaXMsICdmbGF0TWFwRXJyb3JzJyk7XG59O1xuXG4vLyBDb21iaW5lIHR3byBvYnNlcnZhYmxlc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gKFN0cmVhbSwgU3RyZWFtfFByb3BlcnR5KSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgU3RyZWFtfFByb3BlcnR5KSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmlsdGVyQnkgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgcmV0dXJuIGZpbHRlckJ5KHRoaXMsIG90aGVyKTtcbn07XG5cbi8vIChTdHJlYW0sIFN0cmVhbXxQcm9wZXJ0eSwgRnVuY3Rpb258dW5kZWZpZW5kKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgU3RyZWFtfFByb3BlcnR5LCBGdW5jdGlvbnx1bmRlZmllbmQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5zYW1wbGVkQnkgPSBmdW5jdGlvbiAob3RoZXIsIGNvbWJpbmF0b3IpIHtcbiAgcmV0dXJuIHNhbXBsZWRCeSh0aGlzLCBvdGhlciwgY29tYmluYXRvcik7XG59O1xuXG4vLyAoU3RyZWFtLCBTdHJlYW18UHJvcGVydHkpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBTdHJlYW18UHJvcGVydHkpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwVW50aWxCeSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICByZXR1cm4gc2tpcFVudGlsQnkodGhpcywgb3RoZXIpO1xufTtcblxuLy8gKFN0cmVhbSwgU3RyZWFtfFByb3BlcnR5KSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgU3RyZWFtfFByb3BlcnR5KSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZVVudGlsQnkgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgcmV0dXJuIHRha2VVbnRpbEJ5KHRoaXMsIG90aGVyKTtcbn07XG5cbi8vIE9wdGlvbnMgPSB7Zmx1c2hPbkVuZDogYm9vbGVhbnx1bmRlZmluZWR9XG4vLyAoU3RyZWFtLCBTdHJlYW18UHJvcGVydHksIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgU3RyZWFtfFByb3BlcnR5LCBPcHRpb25zfHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlckJ5ID0gZnVuY3Rpb24gKG90aGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBidWZmZXJCeSh0aGlzLCBvdGhlciwgb3B0aW9ucyk7XG59O1xuXG4vLyBPcHRpb25zID0ge2ZsdXNoT25FbmQ6IGJvb2xlYW58dW5kZWZpbmVkfVxuLy8gKFN0cmVhbSwgU3RyZWFtfFByb3BlcnR5LCBPcHRpb25zfHVuZGVmaW5lZCkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIFN0cmVhbXxQcm9wZXJ0eSwgT3B0aW9uc3x1bmRlZmluZWQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5idWZmZXJXaGlsZUJ5ID0gZnVuY3Rpb24gKG90aGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBidWZmZXJXaGlsZUJ5KHRoaXMsIG90aGVyLCBvcHRpb25zKTtcbn07XG5cbi8vIERlcHJlY2F0ZWRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBERVBSRUNBVElPTl9XQVJOSU5HUyA9IHRydWU7XG5mdW5jdGlvbiBkaXNzYWJsZURlcHJlY2F0aW9uV2FybmluZ3MoKSB7XG4gIERFUFJFQ0FUSU9OX1dBUk5JTkdTID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gIGlmIChERVBSRUNBVElPTl9XQVJOSU5HUyAmJiBjb25zb2xlICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgbXNnMiA9ICdcXG5IZXJlIGlzIGFuIEVycm9yIG9iamVjdCBmb3IgeW91IGNvbnRhaW5pbmcgdGhlIGNhbGwgc3RhY2s6JztcbiAgICBjb25zb2xlLndhcm4obXNnLCBtc2cyLCBuZXcgRXJyb3IoKSk7XG4gIH1cbn1cblxuLy8gKFN0cmVhbXxQcm9wZXJ0eSwgU3RyZWFtfFByb3BlcnR5KSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYXdhaXRpbmcgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgd2FybignWW91IGFyZSB1c2luZyBkZXByZWNhdGVkIC5hd2FpdGluZygpIG1ldGhvZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWZpcmpzL2tlZmlyL2lzc3Vlcy8xNDUnKTtcbiAgcmV0dXJuIGF3YWl0aW5nKHRoaXMsIG90aGVyKTtcbn07XG5cbi8vIChTdHJlYW0sIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnZhbHVlc1RvRXJyb3JzID0gZnVuY3Rpb24gKGZuKSB7XG4gIHdhcm4oJ1lvdSBhcmUgdXNpbmcgZGVwcmVjYXRlZCAudmFsdWVzVG9FcnJvcnMoKSBtZXRob2QsIHNlZSBodHRwczovL2dpdGh1Yi5jb20va2VmaXJqcy9rZWZpci9pc3N1ZXMvMTQ5Jyk7XG4gIHJldHVybiB2YWx1ZXNUb0Vycm9ycyh0aGlzLCBmbik7XG59O1xuXG4vLyAoU3RyZWFtLCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5lcnJvcnNUb1ZhbHVlcyA9IGZ1bmN0aW9uIChmbikge1xuICB3YXJuKCdZb3UgYXJlIHVzaW5nIGRlcHJlY2F0ZWQgLmVycm9yc1RvVmFsdWVzKCkgbWV0aG9kLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2tlZmlyanMva2VmaXIvaXNzdWVzLzE0OScpO1xuICByZXR1cm4gZXJyb3JzVG9WYWx1ZXModGhpcywgZm4pO1xufTtcblxuLy8gKFN0cmVhbSkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHkpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5lbmRPbkVycm9yID0gZnVuY3Rpb24gKCkge1xuICB3YXJuKCdZb3UgYXJlIHVzaW5nIGRlcHJlY2F0ZWQgLmVuZE9uRXJyb3IoKSBtZXRob2QsIHNlZSBodHRwczovL2dpdGh1Yi5jb20va2VmaXJqcy9rZWZpci9pc3N1ZXMvMTUwJyk7XG4gIHJldHVybiBlbmRPbkVycm9yKHRoaXMpO1xufTtcblxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIEtlZmlyID0ge1xuICBPYnNlcnZhYmxlOiBPYnNlcnZhYmxlLFxuICBTdHJlYW06IFN0cmVhbSxcbiAgUHJvcGVydHk6IFByb3BlcnR5LFxuICBuZXZlcjogbmV2ZXIsXG4gIGxhdGVyOiBsYXRlcixcbiAgaW50ZXJ2YWw6IGludGVydmFsLFxuICBzZXF1ZW50aWFsbHk6IHNlcXVlbnRpYWxseSxcbiAgZnJvbVBvbGw6IGZyb21Qb2xsLFxuICB3aXRoSW50ZXJ2YWw6IHdpdGhJbnRlcnZhbCxcbiAgZnJvbUNhbGxiYWNrOiBmcm9tQ2FsbGJhY2ssXG4gIGZyb21Ob2RlQ2FsbGJhY2s6IGZyb21Ob2RlQ2FsbGJhY2ssXG4gIGZyb21FdmVudHM6IGZyb21FdmVudHMsXG4gIHN0cmVhbTogc3RyZWFtLFxuICBjb25zdGFudDogY29uc3RhbnQsXG4gIGNvbnN0YW50RXJyb3I6IGNvbnN0YW50RXJyb3IsXG4gIGZyb21Qcm9taXNlOiBmcm9tUHJvbWlzZSxcbiAgZnJvbUVTT2JzZXJ2YWJsZTogZnJvbUVTT2JzZXJ2YWJsZSxcbiAgY29tYmluZTogY29tYmluZSxcbiAgemlwOiB6aXAsXG4gIG1lcmdlOiBtZXJnZSxcbiAgY29uY2F0OiBjb25jYXQkMSxcbiAgUG9vbDogUG9vbCxcbiAgcG9vbDogcG9vbCxcbiAgcmVwZWF0OiByZXBlYXQsXG4gIHN0YXRpY0xhbmQ6IHN0YXRpY0xhbmRcbn07XG5cbktlZmlyLktlZmlyID0gS2VmaXI7XG5cbmV4cG9ydCB7IGRpc3NhYmxlRGVwcmVjYXRpb25XYXJuaW5ncywgS2VmaXIsIE9ic2VydmFibGUsIFN0cmVhbSwgUHJvcGVydHksIG5ldmVyLCBsYXRlciwgaW50ZXJ2YWwsIHNlcXVlbnRpYWxseSwgZnJvbVBvbGwsIHdpdGhJbnRlcnZhbCwgZnJvbUNhbGxiYWNrLCBmcm9tTm9kZUNhbGxiYWNrLCBmcm9tRXZlbnRzLCBzdHJlYW0sIGNvbnN0YW50LCBjb25zdGFudEVycm9yLCBmcm9tUHJvbWlzZSwgZnJvbUVTT2JzZXJ2YWJsZSwgY29tYmluZSwgemlwLCBtZXJnZSwgY29uY2F0JDEgYXMgY29uY2F0LCBQb29sLCBwb29sLCByZXBlYXQsIHN0YXRpY0xhbmQgfTtleHBvcnQgZGVmYXVsdCBLZWZpcjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},1:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/kefir/dist/kefir.esm.js\nvar kefir_esm = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/kefir-tests/kefir-test.js\n\r\n\r\nconst div = document.createElement('div');\r\ndiv.id = 'kefir-square-1';\r\ndiv.style.width = '100px';\r\ndiv.style.height = '100px';\r\ndiv.style.backgroundColor = 'blue';\r\ndiv.style.cursor = 'move';\r\ndiv.style.position = 'absolute';\r\ndiv.style.zIndex = 1;\r\ndiv.style.left = 0;\r\ndiv.style.top = 0;\r\ndocument.body.appendChild(div);\r\n\r\nconst divSecond = document.createElement('div');\r\ndivSecond.id = 'kefir-square-2';\r\ndivSecond.style.width = '100px';\r\ndivSecond.style.height = '100px';\r\ndivSecond.style.backgroundColor = 'violet';\r\ndivSecond.style.cursor = 'move';\r\ndivSecond.style.position = 'absolute';\r\ndivSecond.style.bottom = 0;\r\ndivSecond.style.right = 0;\r\ndivSecond.style.zIndex = 1;\r\ndocument.body.appendChild(divSecond);\r\n\r\nfunction dragAndDropKefir(item) {\r\n  const mouseDownStream = Object(kefir_esm[\"a\" /* fromEvents */])(item, 'mousedown');\r\n  const mouseMoveStream = Object(kefir_esm[\"a\" /* fromEvents */])(document, 'mousemove');\r\n  const mouseUpStream = Object(kefir_esm[\"a\" /* fromEvents */])(item, 'mouseup');\r\n\r\n  const moves = mouseDownStream.flatMap((downEvent) => {\r\n    return mouseMoveStream.takeUntilBy(mouseUpStream).diff(diffCoordinatesByMoving, downEvent);\r\n  });\r\n\r\n  mouseUpStream.onValue(value => {\r\n    console.log(value);\r\n    checkAnotherItemHere(item);\r\n  });\r\n\r\n  const position = moves.scan(finalCoordinatesAfterUp, {x: item.offsetLeft, y: item.offsetTop});\r\n\r\n  position.onValue(pos => {\r\n    item.style.top = `${pos.y}px`;\r\n    item.style.left = `${pos.x}px`;\r\n  });\r\n}\r\n\r\nfunction diffCoordinatesByMoving(prevCoordinate, nextCoordinate) {\r\n  return {\r\n    x: nextCoordinate.clientX - prevCoordinate.clientX,\r\n    y: nextCoordinate.clientY - prevCoordinate.clientY,\r\n  };\r\n}\r\n\r\nfunction finalCoordinatesAfterUp(currentPosition, move) {\r\n  return {\r\n    x: currentPosition.x + move.x,\r\n    y: currentPosition.y + move.y,\r\n  }\r\n}\r\n\r\nfunction checkAnotherItemHere(item) {\r\n  console.log(item);\r\n}\n// CONCATENATED MODULE: ./src/dnd_native_js/dnd.js\nconst divJS = document.createElement('div');\r\ndivJS.id = 'native-js-square-1';\r\ndivJS.style.width = '100px';\r\ndivJS.style.height = '100px';\r\ndivJS.style.backgroundColor = 'green';\r\ndivJS.style.cursor = 'move';\r\ndivJS.style.position = 'absolute';\r\ndivJS.style.right = 0;\r\ndivJS.style.top = 0;\r\ndivJS.style.zIndex = 1;\r\ndocument.body.appendChild(divJS);\r\n\r\nconst divJSSecond = document.createElement('div');\r\ndivJSSecond.id = 'native-js-square-2';\r\ndivJSSecond.style.width = '100px';\r\ndivJSSecond.style.height = '100px';\r\ndivJSSecond.style.backgroundColor = 'red';\r\ndivJSSecond.style.cursor = 'move';\r\ndivJSSecond.style.position = 'absolute';\r\ndivJSSecond.style.bottom = 0;\r\ndivJSSecond.style.left = 0;\r\ndivJSSecond.style.zIndex = 1;\r\ndocument.body.appendChild(divJSSecond);\r\n\r\nfunction dragAndDropNativeJS(item) {\r\n  item.ondragstart = () => false;\r\n  item.onmousedown = event => {\r\n    const itemCoordinates = getCoordinateOfItem(item);\r\n    const shift = {\r\n      x: event.pageX - itemCoordinates.left,\r\n      y: event.pageY - itemCoordinates.top,\r\n    };\r\n\r\n    document.onmousemove = event => {\r\n      item.style.top = `${event.pageY - shift.y}px`;\r\n      item.style.left = `${event.pageX - shift.x}px`;\r\n    }\r\n\r\n    item.onmouseup = () => {\r\n      document.onmousemove = null;\r\n      item.onmouseup = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getCoordinateOfItem(item) {\r\n  const box = item.getBoundingClientRect();\r\n  return {\r\n    left: box.left + pageXOffset,\r\n    top: box.top + pageYOffset,\r\n  };\r\n}\r\n\n// CONCATENATED MODULE: ./src/index.js\n\r\n\r\ndocument.body.style.backgroundColor = 'lightcyan';\r\ndragAndDropKefir(div);\r\ndragAndDropKefir(divSecond);\r\ndragAndDropNativeJS(divJS);\r\ndragAndDropNativeJS(divJSSecond);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMva2VmaXItdGVzdHMva2VmaXItdGVzdC5qcz9iMmE3Iiwid2VicGFjazovLy8uL3NyYy9kbmRfbmF0aXZlX2pzL2RuZC5qcz9lODYzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz9iNjM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFtQzs7QUFFNUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsMEJBQTBCLHVDQUFVO0FBQ3BDLDBCQUEwQix1Q0FBVTtBQUNwQyx3QkFBd0IsdUNBQVU7O0FBRWxDO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsd0RBQXdELHNDQUFzQzs7QUFFOUY7QUFDQSx3QkFBd0IsTUFBTTtBQUM5Qix5QkFBeUIsTUFBTTtBQUMvQixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7QUNoRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hELDJCQUEyQixzQkFBc0I7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuRDRFO0FBQ0U7QUFDOUU7QUFDQSxnQkFBZ0IsQ0FBQyxHQUFHO0FBQ3BCLGdCQUFnQixDQUFDLFNBQVM7QUFDMUIsbUJBQW1CLENBQUMsS0FBSztBQUN6QixtQkFBbUIsQ0FBQyxXQUFXIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmcm9tRXZlbnRzIH0gZnJvbSAna2VmaXInO1xyXG5cclxuZXhwb3J0IGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5kaXYuaWQgPSAna2VmaXItc3F1YXJlLTEnO1xyXG5kaXYuc3R5bGUud2lkdGggPSAnMTAwcHgnO1xyXG5kaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcclxuZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdibHVlJztcclxuZGl2LnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcclxuZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuZGl2LnN0eWxlLnpJbmRleCA9IDE7XHJcbmRpdi5zdHlsZS5sZWZ0ID0gMDtcclxuZGl2LnN0eWxlLnRvcCA9IDA7XHJcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcclxuXHJcbmV4cG9ydCBjb25zdCBkaXZTZWNvbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuZGl2U2Vjb25kLmlkID0gJ2tlZmlyLXNxdWFyZS0yJztcclxuZGl2U2Vjb25kLnN0eWxlLndpZHRoID0gJzEwMHB4JztcclxuZGl2U2Vjb25kLnN0eWxlLmhlaWdodCA9ICcxMDBweCc7XHJcbmRpdlNlY29uZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAndmlvbGV0JztcclxuZGl2U2Vjb25kLnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcclxuZGl2U2Vjb25kLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuZGl2U2Vjb25kLnN0eWxlLmJvdHRvbSA9IDA7XHJcbmRpdlNlY29uZC5zdHlsZS5yaWdodCA9IDA7XHJcbmRpdlNlY29uZC5zdHlsZS56SW5kZXggPSAxO1xyXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdlNlY29uZCk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZHJhZ0FuZERyb3BLZWZpcihpdGVtKSB7XHJcbiAgY29uc3QgbW91c2VEb3duU3RyZWFtID0gZnJvbUV2ZW50cyhpdGVtLCAnbW91c2Vkb3duJyk7XHJcbiAgY29uc3QgbW91c2VNb3ZlU3RyZWFtID0gZnJvbUV2ZW50cyhkb2N1bWVudCwgJ21vdXNlbW92ZScpO1xyXG4gIGNvbnN0IG1vdXNlVXBTdHJlYW0gPSBmcm9tRXZlbnRzKGl0ZW0sICdtb3VzZXVwJyk7XHJcblxyXG4gIGNvbnN0IG1vdmVzID0gbW91c2VEb3duU3RyZWFtLmZsYXRNYXAoKGRvd25FdmVudCkgPT4ge1xyXG4gICAgcmV0dXJuIG1vdXNlTW92ZVN0cmVhbS50YWtlVW50aWxCeShtb3VzZVVwU3RyZWFtKS5kaWZmKGRpZmZDb29yZGluYXRlc0J5TW92aW5nLCBkb3duRXZlbnQpO1xyXG4gIH0pO1xyXG5cclxuICBtb3VzZVVwU3RyZWFtLm9uVmFsdWUodmFsdWUgPT4ge1xyXG4gICAgY29uc29sZS5sb2codmFsdWUpO1xyXG4gICAgY2hlY2tBbm90aGVySXRlbUhlcmUoaXRlbSk7XHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IHBvc2l0aW9uID0gbW92ZXMuc2NhbihmaW5hbENvb3JkaW5hdGVzQWZ0ZXJVcCwge3g6IGl0ZW0ub2Zmc2V0TGVmdCwgeTogaXRlbS5vZmZzZXRUb3B9KTtcclxuXHJcbiAgcG9zaXRpb24ub25WYWx1ZShwb3MgPT4ge1xyXG4gICAgaXRlbS5zdHlsZS50b3AgPSBgJHtwb3MueX1weGA7XHJcbiAgICBpdGVtLnN0eWxlLmxlZnQgPSBgJHtwb3MueH1weGA7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpZmZDb29yZGluYXRlc0J5TW92aW5nKHByZXZDb29yZGluYXRlLCBuZXh0Q29vcmRpbmF0ZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBuZXh0Q29vcmRpbmF0ZS5jbGllbnRYIC0gcHJldkNvb3JkaW5hdGUuY2xpZW50WCxcclxuICAgIHk6IG5leHRDb29yZGluYXRlLmNsaWVudFkgLSBwcmV2Q29vcmRpbmF0ZS5jbGllbnRZLFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmFsQ29vcmRpbmF0ZXNBZnRlclVwKGN1cnJlbnRQb3NpdGlvbiwgbW92ZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBjdXJyZW50UG9zaXRpb24ueCArIG1vdmUueCxcclxuICAgIHk6IGN1cnJlbnRQb3NpdGlvbi55ICsgbW92ZS55LFxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tBbm90aGVySXRlbUhlcmUoaXRlbSkge1xyXG4gIGNvbnNvbGUubG9nKGl0ZW0pO1xyXG59IiwiZXhwb3J0IGNvbnN0IGRpdkpTID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbmRpdkpTLmlkID0gJ25hdGl2ZS1qcy1zcXVhcmUtMSc7XHJcbmRpdkpTLnN0eWxlLndpZHRoID0gJzEwMHB4JztcclxuZGl2SlMuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcclxuZGl2SlMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2dyZWVuJztcclxuZGl2SlMuc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xyXG5kaXZKUy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbmRpdkpTLnN0eWxlLnJpZ2h0ID0gMDtcclxuZGl2SlMuc3R5bGUudG9wID0gMDtcclxuZGl2SlMuc3R5bGUuekluZGV4ID0gMTtcclxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXZKUyk7XHJcblxyXG5leHBvcnQgY29uc3QgZGl2SlNTZWNvbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuZGl2SlNTZWNvbmQuaWQgPSAnbmF0aXZlLWpzLXNxdWFyZS0yJztcclxuZGl2SlNTZWNvbmQuc3R5bGUud2lkdGggPSAnMTAwcHgnO1xyXG5kaXZKU1NlY29uZC5zdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xyXG5kaXZKU1NlY29uZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmVkJztcclxuZGl2SlNTZWNvbmQuc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xyXG5kaXZKU1NlY29uZC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbmRpdkpTU2Vjb25kLnN0eWxlLmJvdHRvbSA9IDA7XHJcbmRpdkpTU2Vjb25kLnN0eWxlLmxlZnQgPSAwO1xyXG5kaXZKU1NlY29uZC5zdHlsZS56SW5kZXggPSAxO1xyXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdkpTU2Vjb25kKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkcmFnQW5kRHJvcE5hdGl2ZUpTKGl0ZW0pIHtcclxuICBpdGVtLm9uZHJhZ3N0YXJ0ID0gKCkgPT4gZmFsc2U7XHJcbiAgaXRlbS5vbm1vdXNlZG93biA9IGV2ZW50ID0+IHtcclxuICAgIGNvbnN0IGl0ZW1Db29yZGluYXRlcyA9IGdldENvb3JkaW5hdGVPZkl0ZW0oaXRlbSk7XHJcbiAgICBjb25zdCBzaGlmdCA9IHtcclxuICAgICAgeDogZXZlbnQucGFnZVggLSBpdGVtQ29vcmRpbmF0ZXMubGVmdCxcclxuICAgICAgeTogZXZlbnQucGFnZVkgLSBpdGVtQ29vcmRpbmF0ZXMudG9wLFxyXG4gICAgfTtcclxuXHJcbiAgICBkb2N1bWVudC5vbm1vdXNlbW92ZSA9IGV2ZW50ID0+IHtcclxuICAgICAgaXRlbS5zdHlsZS50b3AgPSBgJHtldmVudC5wYWdlWSAtIHNoaWZ0Lnl9cHhgO1xyXG4gICAgICBpdGVtLnN0eWxlLmxlZnQgPSBgJHtldmVudC5wYWdlWCAtIHNoaWZ0Lnh9cHhgO1xyXG4gICAgfVxyXG5cclxuICAgIGl0ZW0ub25tb3VzZXVwID0gKCkgPT4ge1xyXG4gICAgICBkb2N1bWVudC5vbm1vdXNlbW92ZSA9IG51bGw7XHJcbiAgICAgIGl0ZW0ub25tb3VzZXVwID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENvb3JkaW5hdGVPZkl0ZW0oaXRlbSkge1xyXG4gIGNvbnN0IGJveCA9IGl0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGxlZnQ6IGJveC5sZWZ0ICsgcGFnZVhPZmZzZXQsXHJcbiAgICB0b3A6IGJveC50b3AgKyBwYWdlWU9mZnNldCxcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGRyYWdBbmREcm9wS2VmaXIsIGRpdiwgZGl2U2Vjb25kIH0gZnJvbSAnLi9rZWZpci10ZXN0cy9rZWZpci10ZXN0JztcclxuaW1wb3J0IHsgZHJhZ0FuZERyb3BOYXRpdmVKUywgZGl2SlMsIGRpdkpTU2Vjb25kIH0gZnJvbSAnLi9kbmRfbmF0aXZlX2pzL2RuZCc7XHJcbmRvY3VtZW50LmJvZHkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2xpZ2h0Y3lhbic7XHJcbmRyYWdBbmREcm9wS2VmaXIoZGl2KTtcclxuZHJhZ0FuZERyb3BLZWZpcihkaXZTZWNvbmQpO1xyXG5kcmFnQW5kRHJvcE5hdGl2ZUpTKGRpdkpTKTtcclxuZHJhZ0FuZERyb3BOYXRpdmVKUyhkaXZKU1NlY29uZCk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},8:function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n')}});